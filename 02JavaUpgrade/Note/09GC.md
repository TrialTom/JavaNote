# 一、JVM运行时数据区

方法区，Java堆，Java栈，程序计数器，本地方法栈

- **程序计数器** 

  > 一块较小的内存空间，作用可以看作是当前线程所执行的字节码行号指示器（每个线程都有自己的程序计数器，线程隔离）

- **Java虚拟机栈**

  > 每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储<span style="background:yellow;color:red">**局部变量表、操作栈、动态链接、方法出口等信息**</span>。线程私有（线程隔离）

- **本地方法栈（线程私有**）

  > 与虚拟机所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则是为了虚拟机使用到的Native方法服务

- **Java堆**

  > 此区域的唯一目的就是为了存放对象，一个JVM实例只有一个堆，堆内存的大小是可以调节的。最大堆内存默认是系统的四分之一
  >
  > 可以在VM options中通过：**-Xms200m -Xmx300m**	修改最小和最大堆内存

- **方法区（线程共享）**

  > 和Java堆一样，线程共享区域，用于存储数据

图例：

![09JVM虚拟机](E:\javaEE program\02JavaUpgrade\笔记\09JVM虚拟机.png)

橙色区域：线程私有

绿色区域：线程共享区域

蓝色区域：方法区的一种实现方式

# 二、内存管理

## 1. 显式内存管理

1. **概述**：内存管理由程序员控制 C，C++
2. **存在问题**：
   - 野指针：指针指向已被释放的内存空间
   - 内存泄漏：被使用完的内存空间未被释放

## 2. 隐式内存管理

1. **概述**：内存管理由垃圾回收器自动管理，如Java，Python，C#
2. **优点**：增加了程序的可靠性，减小了memory leak
3. **缺点**：无法控制GC时间，耗费系统性能

# 三、GC

## 1. 如何确定垃圾

1. **引用计数算法** 

   - 概述：对象添加一个引用计数器，每当有一个地方引用它时，计数器加一；引用失效时，计数器减一。计数器为零时则为垃圾
   - 问题：无法解决循环引用的情况

2. **根搜索算法** 

   - 概述：以GCRoots的对象作为起始点，当一个对象到所有GCRoots之间没有任何引用链相连时，就认为该对象变成了垃圾

     > GCRoots包含的对象：
     >
     > - **虚拟机中引用的对象，** 
     > - **方法区中静态属性引用的对象** 

## 2. 如何回收垃圾

1. **标记清除算法(Mark Sweep)**：

   - 思想：标记所有需要回收的对象，标记完成后，同一回收所有被标记的对象
   - 缺陷：会造成垃圾碎片

2. **标记复制算法**：

   - 思想：将内存划分为两份，当一份用完后，将上面还存活的对象复制到另一份内存上，把已使用过的内存空间一次清理掉。
   - 缺陷：内存利用率低

3. **标记整理算法（Mark Compact）**：

   - 思想：标记清除后，让所有存活的对象都向内存空间的一段移动，然后直接清除掉边界以外的内存。
   - 缺陷：开销大

4. **分代收集算法**：

   - 思想：

     1. 将内存分为新生代区和老年代区，

     2. 新生代分为Eden（80%），survivor0（10%），survivor1（10%）；survivor1作为保留区，采用标记复制算法。

     3. 新生代中对象熬过15轮垃圾清除，则移动到老年代。老年代中采用标记整理算法

        > 弱分代假说：绝大多数对象都是朝生夕灭
        >
        > 强分代假说：熬过越多次垃圾收集过程的对象越难以消亡

## 3. 何时回收垃圾

1. 申请heap space失败后会触发GC回收
2. 系统进入idle（休眠）后一段时间会进行回收
3. 主动调用GC进行回收（System.gc()）

# 四、GC相关概念

- Shallow size：对象本身占用内存的大小，也就是对象头加成员变量占用内存大小的总和
- Retained size：该对象自己的shallow size加上仅可以从该对象访问的（直接或间接访问）对象的shallow size之和