[TOC]



# 一、异常

## 1.概述

- 描述：**用来表示Java应用程序运行过程中的错误信息**
- Java异常机制的实质：提供了一致性的错误报告模型，使得类的构建者和使用者之间可以进行可靠的沟通。

## 2.体系（以Throwable为祖先）

- Error：程序层面无法处理的错误（致命的错误）

  > JVM内部错误，内存耗尽，栈溢出（StackOverflowError），堆溢出（OutOfMemoryError）
  >
  > JVM最大的堆空间大小是系统的四分之一，Runtime.getRuntime().maxMemory();

- Exception：在程序中可能能够处理的错误

  > 1. 编译时异常
  >    - 可预见的，语法层面强制在代码编写时处理，除了RuntimeException及其子类之外的异常都是是编译时异常
  > 2. 运行时异常
  >    - 不可预见的，不要求在编写代码时必须处理。如：ArithmeticException（算数异常），ArrayIndexOutOfBoundException，NullPointerException

- 注意：**Exception，使用时（自定义异常）Exception作为编译时异常**

# 二、异常处理

## 1.JVM默认处理机制

- JVM默认异常处理流程
  1. 一旦发生错误，JVM终止程序运行，转而执行JVM自己的错误处理流程
  2. 在发生错误地方，收集错误信息，产生一个描述错误的对象
  3. 访问收集到的错误信息，将错误信息，输出到控制台窗口中。
- 执行过程
  - 错误产生在main方法中
    1. 错误之前的行数代码正常执行
    2. 执行到错误行数时，JVM终止程序的执行，抛出一个该异常信息封装成的对象
    3. 将该对象中的异常信息，打印到控制台，
    4. 错误之后的代码不执行
  - 错误产生在main方法当中的另一个方法中
    1. 执行到错误行数，JVM终止程序的执行，向上给调用者抛出一个异常信息封装成的对象
    2. 一直向上抛出，直到抛给main方法，main方法最终抛给JVM
    3. 异常之前的正常执行，异常之后的不执行
  - **<span style="background:yellow;color:red">默认处理机制仅针对运行时异常</span>**

## 2.捕获异常，自己处理

1. try-catch

   - 单分支语法：

   ```java
   try{
       //可能发生错误的代码块
   }catch(异常类型 对象名){
       //对于异常的处理
   }
   
   
   try{
       //可能发生错误的代码块
   }catch(异常类型1 | 异常类型2 对象名){
       //对异常的处理
   }
   
   ```

   - 多分支语法

   ```java
   try{
       //可能发生异常的代码
   }catch（异常类型1 对象名）{
       //对于异常的处理
   }catch（异常类型2 对象名）{
       //对于异常的处理
   }...
   ```

   > 多分支匹配规则
   >
   > 1. 从上到下做类型匹配
   > 2. 只会执行多个catch分支中的一个
   > 3. catch分支有个父子关系，儿子放前面，父亲放后面

2. 获取异常信息

   获取异常信息的方法，都是定义在Throwable类中

   - `getMessage（）；`

     获取错误的原因，返回字符串

   - `toString（）；`

     获取异常类名和错误的原因，返回字符串

   - `printStackTrace（）；`

     获取异常类名和错误原因，以及异常出现在程序中的位置，并打印到控制台

## 3.抛出异常，上层处理

1. 异常处理

   - throws关键字

     > 1. 使用
     >
     >    - **在方法定义时使用**
     >    - 声明该方法可能抛出异常
     >    - 对于编译时异常，可以在语法层面强制方法调用者 处理该异常
     >
     > 2. 基本语法
     >
     >    `修饰符 返回值 方法名(形参列表) throws 异常列表{}`
     >
     > 3. 注意事项
     >
     >    - 异常列表之间用逗号分割，列表中出现的异常不要出现包含关系
     >    - 方法覆盖时的子类异常列表必须与父类兼容，**子类重写父类方法时，不能抛出比父类更多的编译时异常。**
     >    - **throws+运行时异常没有意义**，因为运行时异常会自动抛出，不需要声明。**throws+编译时异常才有意义**，这实际上是编译异常处理的一种方式。
     >    - 在方法中声明throws+编译时异常，声明可能抛出编译时异常，该方法被调用时就要处理这个编译异常
     >    - 处理编译时异常：
     >      1. 方法内部try-catch
     >      2. throw向上抛，如果在main中就别抛了 
     
   - throw关键字

     >1. 使用
     >
     >   - **在方法体中使用**
     >   - 主动在程序中抛出异常
     >   - 每次只能抛出确定的某个异常
     >
     >2. 基本语法：
     >
     >   `throw 异常对象(一般是new出来的);`
     >
     >3. 注意事项
     >
     >   - 若要抛出编译时异常，要配合throws使用

## 4.异常策略的选择

1. 两种策略
   - 捕获并处理try-catch
   - 向上抛出
     - 运行时异常，自动抛出，直接抛给JVM
     - 编译时异常，需要结合throws关键字向上抛
2. 如何选择
   - 对于运行时异常，不处理，改代码
   - 对于编译时异常，功能内部能处理就处理，否则就抛出

# 三、finally

1. 特点

   - finally控制的语句体一定会执行
   - 特殊情况：在执行finally之前JVM退出（如：System.exit(0);）

2. 作用

   - 用于释放资源，在IO流中操作

3. 语法：

   ```java
   //结构一
   try{
       
   }catch(){
   
   }finally{
       //一定会执行的代码
   }
   
   // 结构二
   try{
       
   }finally{
       
   }
   ```

4. 注意事项

   - try代码块中有return，程序会先执行完finally代码块，回过头执行try中的return
   - catch中有return，并且catch正常捕获异常执行，程序会先执行finally代码块后，在回去执行catch中return，
   - finally代码块中有return，不会影响finally代码块的执行
   - 如果try中的异常不能正常捕获，但是finally中有return，**此时程序会跳过这个异常，不会抛出异常给JVM报错**

5. final与finally的区别

   > final关键字，修饰类，成员变量，成员方法
   >
   > - 修饰类，该类不能被继承
   > - 修饰变量表示一个常量
   > - 修饰方法表示无法重写的方法
   >
   > finally代码块，和try...catch一起使用，具有必然执行的特点
   >
   > - 异常处理体系中，用于资源释放

# 四、自定义异常

## 1.如何自定义异常

- 编译时异常：定义一个类继承Exception
- 运行时异常：定义一个类继承RuntimeException

