[TOC]



# 一、匿名内部类

## 1.概述

- 匿名内部类是特殊的局部内部类，它任然定义在方法等局部位置，也仅在作用域内部生效，就是局部内部类的简化
- 成员特点，使用特点，访问特点等都和局部内部类类似

## 2.语法

`new 类名/接口名(){ //上面类或接口的子类的类体 }`

- new关键字表示创建对象，所以该匿名内部类语法，整体表示一个对象，而不是一个类
- 整个语法表示的对象，是语法中写的类名/接口名的子类对象，所以匿名对象内部类的语法中，<span style="background:yellow;color:red">隐含了继承或者实现</span>
- 整个语法表示创建子类对象，类体中可重写父类方法
- 类名可以是普通类，也可以是抽象类

## 3.使用

1. 可以用引用接收，这时就不是匿名对象
   - 若接收，则必须，也只能用父类引用接收，接收完毕后，就可以使用引用操作对象
   - 缺点：无法访问子类独有成员，而且是真的无法访问，不能强转，因为不知道子类叫什么。
2. 可以直接调用，访问方法
   - 优点：可以访问子类所有成员
   - 缺点：一次性的，无法多次使用

## 4.注意事项

- 匿名内部类没有构造器
- 匿名构造器中的小括号，可以用来调用父类的构造器。

## 5.使用场景

- 基本覆盖了局部内部类，因为它比局部内部类的语法更加简洁
- 在局部位置，需要创建一个外部类的子类对象，或者外部接口的实现对象，用匿名内部类的语法更加简洁。

# 二、Lambda

## 1.概述

- Lambda表达式时JDK8的一个新的特性，**取代接口的匿名内部类**，简化了局部内部类

  > 1. Lambda表达式仍然是局部内部类，是特殊的局部内部类
  > 2. Lambda表达式取代匿名内部类时，不是全部取代，而是取代接口的匿名内部类，而类的匿名内部类是不能取代的
  >    - Lambda表达式简化接口的匿名内部类，必须要求这个接口是功能接口（Function interface）
  >      - 功能接口：接口中有且仅有一个必须要求子类实现的抽象方法的接口，使用注解@Functional Interface。但是不是只能有一个接口，因为Java8中还有默认方法和静态方法，不需要子类实现。	
  >      - 因为Lambda表达式只有一套用于方法重写的方法体和形参，所以只能表示重写一个方法，所以功能接口中，才要求有且仅有一个必须要求子类实现的抽象方法。
  > 3. Lambda表达式得到的也不是一个类，而是一个对象，并且是接口的子类对象。
  
- **lambda表达式的本质就是把一个方法实现作为一个对象**

## 2.语法

- `() -> {}`

  > () ：是功能接口中那个必须实现的抽象方法的形参列表
  >
  > -> : 是Lambda表达式的运算符，可以读作“goes to”
  >
  > <span style="background:yellow;color:red">{} : 是功能接口中那个要必须实现的抽象方法的重写方法体，不是类体。</span>

## 3.Lambda表达式的类型推断

- 类型推断需要借助代码的上下问额外信息

  1. 可用直接用父接口引用接收，这是最简单的方式

  2. 使用lambda表达式类型推断的特殊语法：

     `((父接口的名字)Lambda表达式).方法名(实参列表)；`

  3. **借助方法的返回值类型完成类型推断**

  4. **借助方法的形参数据类型完成类型推断**

## 4.Lambda表达式的简化

1. 前提：
   - 它是功能接口的子类对象，而功能接口中有且只有一个必须要实现的抽象方法。
2. 简化原则：
   - 简化不能导致Lambda表达式有歧义
3. 简化语法：
   - （）简化：
     1. 形参列表中的数据类型，不管写不写都是不会变的，所以为了简化，干脆就不要写了
     2. 特殊的，当形参只有一个时，可以省略小括号，直接写形参的名字；方法是无参的，小括号不能省略
   - {}简化：
     1. 当重写的方法语句只有一条时，可以省略{}；
     2. 特殊的，当那一条就是返回值语句时，可以连带着省略大括号和return关键字。 

## 5.方法引用

1. 方法能够作为Lambda表达式的实现的条件

   - 返回值类型

     > 1. 基本数据类型和void保持一致
     > 2. 引用数据类型，抽象方法是父类类型，已实现的这个子类方法可以返回子类类型。

   - 方法名无所谓，

   - 形参列表也必须完全一致

   - 方法体无所谓

   - 修饰符也无所谓

2. 语法

   > `() ->  已实现的方法（形参列表）;`

3. 注意：

   - 如果是同类中直接些方法名即可
   - 如果不是同类，就必须要指出方法来自哪里（通过类名或者对象名访问）
   - Lambda表达式访问作用域内部的局部变量，那么这个局部变量应该是一个常量。
   - Lambda表达式和局部内部类、匿名内部类稍有不同的地方在于，Lambda表达式的大括号没有自己的作用域，和装有Lambda表达式的局部位置共用一个作用域

4. 方法引用的简化，最简单的Lambda表达式形式：

   `接口名 对象名 = 方法的归属者：：方法名;`

   > 方法的归属者：：方法名；就是一个Lambda表达式
   >
   > 方法的归属者：1. static方法属于类 2. 成员方法属于对象
   
5. 扩展（使用场景）

   Lambda表达式的本质就是将一个方法作为一个对象，实际应用场景下，这个对象依赖于这个方法可以用来表示一种灵活的规则，比较典型的有：过滤（filter），映射（map），排序（sort）