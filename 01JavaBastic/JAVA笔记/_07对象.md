[TOC]



# 一、匿名对象

## 1.概述

- 匿名对象，没有名字的对象，对于对象来说，引用是它的“名字”，所以匿名对象就是没有引用指向它的对象

## 2.语法

- `new 类名（实参列表）;`

## 3.用法

- 由于没有引用指向匿名对象，所以匿名对象必须在创建的时候直接使用，
- `new 类名（实参列表）.`使用

# 二、代码块

## 1.概念

- 由若干条Java语句组成，并且用一对大括号括起来的结构，叫做代码块

## 2.分类

1. 局部代码块（没啥用）

   > - 定义：指的是定义在局部位置的代码块，它其实是一种嵌套定义的代码块
   > - 语法：`{ }`
   > - 定义位置：局部位置
   > - 作用：没啥鸟用,套娃套多了还影响可读性
   > - 背景故事：早期JVM性能低下时，程序员需要从细微处“扣”出性能的差异，比如局部代码块。而现代JVM已经比较成熟了，不缺少这样一点点性能，使用局部代码块得不偿失。

2. <span style="background:yellow;color:red">构造代码块（重要）</span>

   > - 语法：`{}`
   >
   > - 定义位置：类体中的成员位置，和构造器一样
   >
   > - 作用：随着构造器的执行而执行，用来在创建对象过程中，给成员变量赋值
   >
   > - 总结赋值方式：
   >
   >   - 默认初始化，具有默认值
   >
   >   - 显示赋值
   >
   >   - 构造器
   >
   >   - 构造代码块
   >
   >     > 1. 默认初始化是永远的第一步，构造器永远最后一步执行
   >     > 2. 显式赋值和构造代码块赋值顺序是：按照代码块的书写顺序，从上到下执行
   >
   > - 原理：编译后的代码中并不存在构造代码块的结构，编译器会智能的将构造代码块中的赋值语句和显式赋值语句，放入类中所有构造器的前几行语句。保证显示赋值和构造代码块赋值按照代码书写顺序从上到下执行。
   >
   > - 结论：
   >
   >   - 使用new对象的方式创建对象，不论使用那个构造器，构造代码块都会随之执行。

3. 静态代码块（重要）

   >- 语法：`static {}`
   >- 定义位置：类体中的成员位置
   >- 作用：在类加载过程中，用于给静态成员变量赋值。可以把它当成是一个类加载过程中，自动调用的静态成员方法
   >- 总结来加载过程中，给静态成员变量赋值的方式：
   >  1. 默认初始化，具有默认值
   >  2. 显式赋值
   >  3. 静态代码块赋值
   >- 默认初始化最先进行，显式赋值和静态代码块赋值会按照代码的书写顺序从上到下执行

4. 同步代码块（重要，多线程知识）

## 3.目前所学的，各种结构的执行顺序

1. 对象结构存在后就进行默认初始化，所有成员变量都具有默认值后，再开始其余赋值操作
2. 找到new对象的那个构造器
   - 如果它的首行显式的调用了另一个构造器（指的的是this调用自身构造器）
     - <span style="background:yellow;color:red">那么程序会先跳转到那个构造器，但是不会立刻执行，而是：按照类中构造代码块和显式赋值的代码书写顺序，从上到下执行其中的代码，执行完毕后；</span>
     - 跳转回this或者super执行的构造器，执行完毕后；
     - 最终跳转回new对象构造器，执行完毕后，创建对象结束
   - 如果它的首行没有显式调用另一个构造器
     - 那么会先从上到下执行构造代码块和显式赋值代码，执行完毕后；
     - 跳转会new对象构造器，执行完毕后，创建对象结束。

# 三、类加载的详细流程

- ## 一个类的加载和卸载，大体上分为五个步骤：

  > 加载 -->链接 -->初始化 -->使用 -->卸载
  >
  > 1. 加载：主要是将二进制数据读取进方法区
  > 2. 链接：
  >    - 验证二进制的数据是否合法
  >    - 完成静态成员变量的开辟空间和默认初始化
  > 3. 初始化
  >    - 主要是完成和static相关声明的代码，比如静态成员变量的显式赋值，静态代码块的执行

- <span style="background:yellow;color:red">类加载过程中，实际上只要经过了加载和链接，就能够创见这个类的对象</span>

# 四、类中结构在new对象时的执行顺序

1. 静态代码块（或静态成员变量的显式赋值，它们按照代码顺序从上到下执行）
2. 构造代码块（或成员变量的显式赋值，它们按照代码顺序从上到下执行）
3. this构造器
4. new对象的构造器
5. 结束

# 五、导包

## 1. package关键字

- 作用：它写在Java源文件的第一行，用于声明整个Java文件下的所有类的所属包。所有一个包下的所有类都是同包关系，不管在不在一个java文件中。
- 注意事项：
  1. 如果代码直接写在src目录下，不需要package。注：实际开发中绝不会把代码直接写在src目录下
  2. package声明应该放在java文件有效代码的第一行，当然注释不算有效代码
  3. 正常情况下，package声明不要管，idea生成不会出错，拷贝删除，alt+enter

## 2.import关键字

1. ### 引入：

   - 编译器在确定使用某个类时，会优先从同包下查找，当使用简单类名时，同包下是不可能由同名类的；

   - 如果想要跨包访问一个类时，不同包下完全允许同名类，这时再使用简单类名就不可以访问了；所以跨包使用某个类时：

     > 1. 要么使用导包语句 
     >    - 语法：import 类的全限定类名
     >    - 语法使用位置：package声明下面；类声明的上面
     > 2. 使用类时，不用简单类名，而是用全限定类名（可行，但尽量不要使用）

2. ### 注意事项：

   - Java.lang包下的类都是java的核心类，这些类会存在隐式导入，对于任何java代码而言，都存在它们的隐式导入
   - 如果存在想使用同包下和不同包下的两个同名类的场景：
     - 这种情况如果发生，尽量先考虑改名字
     - 考虑一个用全限定类名，另一个直接同包使用

3. ### 小细节：

   1. 智能导入：
      - 概述：指的是在包后面+“*”，用星号表示通配，智能地导入改包下的类，按需导入
      - 语法：import 包名 *
      - 原理：所谓智能，指的是如果不导包就会报错，才会进行导包，经典场景就是同包下如果存在同名类，那么智能导入就会不进行导包了
   2. 静态导入
      - 概述：前面说的所有import导入都是指导入一个class，一个类进行使用，但是静态导入指的是导入某个类中的静态成员（变量和方法）
      - 语法：import static 类的静态成员变量和方法
        - 也存在使用*统配的情况
      - 牺牲了代码可读性，不建议使用，开发中很少见
   3. 编译单元
      - 概述：Java中把一个Java文件视为一个编译单元，同一个编译单元下，不允许使用导包语句导入同名类

# 六、访问权限修饰符

1. 概述：
   - 在Java语言中，一切事物（类和类的所有成员）都具有（或显式定义或隐式定义的）访问权限，而这种语言层面的访问权限控制，是由访问权限修饰符实现的。
2. 四种访问权限：
   - Java中的访问权限级别是分层级的，使用包作为划分访问权限的依据
     - 严格点，仅允许在自己（类中）使用，它对应关键字private
     - 宽松点，同包下都够使用，它不对应任何关键字，只要在访问权限修饰符的位置不写任何关键字即可。它也叫默认的访问权限
     - 不同包下的子类可以使用，它对应关键字protected，也叫受保护的访问权限
     - 不同包下任意使用，相当于没有访问权限控制，对应public
3. 限制
   1. 修饰类时，只能用public和默认权限，没有私有，没有受保护
      - 独立定义的类，没有对谁私有，受谁保护的概念
      - 当然类不仅可以单独定义，还可以嵌套定义在另一个类的内部，内部类就可以拥有四种访问权限
   2. 修饰成员，静态成员以及构造器时，四种访问级别都是可以的
4. 作用：
   - 告诉代码的使用者，那些地方不要触碰，那些地方应该使用。起到警告、约束和指导代码使用者的功能
5. 案例
   - 工具类：工具类中都是静态方法，不需要创建对象使用，对于工具类来说，它的对象没有任何意义；于是这个不应该创建对象，应该私有化它的构造器，禁止创建对象。
   - 类中提供给外界使用的方法，普遍使用public修饰。类中那些实现public方法而写的中间方法（过程方法）不需要外界有权限，应该私有化它们
   - 简单设计模式，
     - 单例模式：单例指的是在整个程序中，在整个JVM内存中，仅存一个某个类的对象，这个对象叫做单例
       - 两种简单的单例模式实现：
         1. 懒汉模式：指的是只有在确定要使用这个类对象时，才创建这个类对象
         2. 饿汉模式：指的是在一开始，程序启动就立刻创建该类对象，无需在使用它时在创建
     - 工厂模式：指的是不在自身类中创建对象，而是在一个叫做“工厂”的类中创建对象，利用其它类来创建对象，这种情况下该类的构造器应该私有化，然后再外部工厂中创建它的对象（普遍利用反射）
6. 遵循的原则：
   - 应该尽量私有化，如果不能私有化，应该尽量少的给予访问权限，尽量少给非public，除非有必要

# 七、OOP面向过程开发

## 1.POP与OOP概述

- POP：只要是完全依赖于方法调用，按照流程走完，实现功能的程序，都可以说是具有面向过程思想的程序。
- OOP：对于面向对象的编程思想来说：程序是“个体”的合集，程序的基本单位是对象，程序是由一个个的个体（对象）组成，对象之间产生交互，协同完成程序的某个功能；<span style="background:yellow;color:red">本质上任然是方法调用完成程序功能，所以面向对象思想实际上和面向过程并不冲突</span>

## 2.优缺点

- POP面向过程思想编程的优缺点
  - 优点：
    1. 流程化使得编程目标明确，在开发之前就已经基本知道，程序每一个步骤的实现方式和最终结果
    2. 面向过程的代码往往简洁明了，配合良好数据结构设计，程序的执行效率也很高

  - 缺点：
    1.  很多时候是不可能做到在编程前思考整个流程的，
    2. 方法连接十分紧密，代码几乎不能重复使用
    3. 对程序员的要求很高，要求程序员熟悉整个流程，实际开发几乎不可能。

- OOP面向对象思想的优缺点

  - 优点：
    1. 不同的对象功能不同，进而就可以将程序模块化设计、分割
    2. 面向对象思想模块化编程，<span style="background:yellow;color:red">代码之间的关联会小很多（低耦合）可以实现代码复用，程序可以更好的应对需求变更，程序的扩展性会更好，可维护性会更强。</span>
  - 缺点：
    1. 面向对象思想编程有把简单问题，复杂化的趋势。简单问题不适用。
    2. 内存开销大运行效率低。面向对象的程序代码往往都十分庞大。