[TOC]



# 一、Object引入

## 1.API的概述

> API,全程Application Programming Interface，也就是应用程序编程接口。

## 2.Object概述

> Object是没有成员变量定义的，并且由于子类对象的隐式初始化，Object类有且仅有一个默认提供的无参构造方法。

## 3.Object类的成员方法

> - public final Class getClass()
>   - 获取Class对象，Class对象是反射的基础
>
> - public String toString()
>   - 提供了将对象字符串化的手段
>
> - public boolean equals(Object obj)
>   - 判断对象是否相等，重点
>
> - public int hashCode()
>   - 返回对象的哈希值，重点
>
> - protected void finalize()
>   - 在Java9中，该方法用注解“@Deprecated”标记它，表示他是一个过时的，弃用的方法
>
> - protected Object clone()
>   - 克隆得到一个对象，它是一种全新的创建对象的方式（不同于new对象）

# 二、getClass方法

## 1.方法的声明

`public final native Class<?> getClass();`

> native表示它是一个本地方法，所以不需要关注他的实现，只要关心合作即可。
>
> Class是方法的返回值类型，表示该方法返回一个Class对象
>
> <?>这是泛型，集合中说明。这里略过它，此泛型是伪泛型，对程序的运行没有影响，仅影响编译

## 2.作用

> 该方法的作用是返回一个该对象（调用该方法的一个对象）的Class对象（也叫运行时类对象）
>
> > - 引入：类加载过程是JVM了解认识该类型的过程，但是程序的运行期间，程序员对类型信息是一无所知的，但是程序员有在程序运行期间了解类型信息的需求
> > - 解决：为了满足程序员的这种需求，JVM在类加载时期会自动在堆上创建一个对象---这个对象中装着该类的类型信息，比如类中有什么成员变量、方法、构造器。程序员只要获取这个对象，就能够在程序运行期间获取类型信息，这个对象就是Class对象。
>
> **Class对象是类的运行时对象，它是在类加载过程中，JVM自动创建的，它的作用在程序运行期间，帮助程序员获取类型信息**

## 3.注意事项

1. <span style="background:yellow;color:red">Class对象是JVm创建的，不是getClass方法创建的，</span>getClass方法不过是让引用指向Class对象，有了引用之后，我们才可以操作创建对象

2. 某个类的类加载在程序一次运行期间，仅有一次。所以运行时Class对象，也只有一个。

   > **如果两个引用调用getClass的返回值用"=="连接，返回结果true，这表示两个引用指向的对象是同种类型的对象，（严格的同种类型，父子类对象也不能）。**

3. 类对象 = Class对象。

4. Class对象是反射的基础。

# 三、toString方法

## 1.方法声明

`public String toString()`

> 无参，并且有String类型的返回值

## 2.方法作用

> - 将一个对象变成字符串表示，这个字符串要能够简介明了的表示这个对象。
> - 最后，设计者希望程序员能够根据不同场景，自己去实现toString方法

## 3.Object类中的toString方法实现

`return getClass().getName() + "@" + Integer.toHexString(hashCode());`

> - this.getClass()是获取某个类的运行时Class对象
> - this.getClass().getName()获取这个对象的类全限定类名。
> - Integer.toHexString(int)它是将一个int数值变成一个十六进制的字符串。
> - hashCode():它是通过将一个对象的地址转换成一个十进制数。这个方法的返回值是对象地址的十进制表示。
>
> **总结：Object类当中的toString方法默认实现：全限定类名+"@"+十六进制地址值字符串。**

## 4.注意事项

1. Java中直接输出一个引用或者某个引用参与了字符串的拼接运算，那么输出的结果是toString方法的结果，拼接的对象会自动调用toString 方法，让字符串参与拼接。
2. toString方法的作用在大多数情况下就是为查看成员变量的取值，只需要访问取值即可。
3. **在IDEA的debug模式中，当代码运行完创建对象的语句后，会在语句后面打印该对象的信息**（这是通过调用toString方法实现的）
4. 如果类中有引用数据类型的成员变量，那么需要继续重写那个类中的toString方法。
5. 在输出引用或者使用引用拼接字符串时，会自动调用该对象的toString方法，不需要手写。

# 四、equals方法

## 1.方法声明

`public boolean equals(Object obj);`

> 返回值是一个布尔类型，需要一个Object参数，

## 2.方法的作用

用来判断两个对象是否相等（方法的调用者和方法的传入的对象比较）

## 3.比较规则

- 默认实现的方法体：`return (this == obj);`

  > 所以默认情况下，只有当两个引用完全指向同一个对象时，对象才相等。

## 4.重写equals方法的对象相等规则

1. 当两个对象是完全的同种类型对象时，属性取值只要相等，对象就相等。

2. 当两个对象不是同种类型对象时，没有可比性，直接判断不等。

   > JDK文档中，提供了重写该方法的原则
   >
   > 1. 自反性：对于任何非空引用值x，`x.equals(x)`都应返回true
   >
   > 2. 排他性：当比对的不是同种类型的对象或者是一个null时，默认返回false；
   >
   >    > 实现的两种方式
   >    >
   >    > - getClass，严格判断是否同一个类型，只要不是同种类型，就直接返回false，不关心是不是子类
   >    > - instanceof，判断引用所指向的对象是否是后面类名的对象或者子类对象。用这种方式判断排它性，允许子类传入equals方法。
   >
   > 3. 对称性：对于任何非空引用值x和y，当且仅当`y.equals(x)`返回true时，`x.equals(y)`才应返回true
   >
   > 4. 传递性：x和y相等，y和z相等，那么x和z相等。
   >
   > 5. 一致性：：对于任何非空引用值x和y，只要条件不变，多次调用`y.equals(x)`始终返回true或者始终返回false；

## 5.注意事项

1. equals方法的重写可以用alt + insert快捷键生成

2. 浮点数包括double，float，他们是比较特殊的，存在无穷大，无穷小，非数（NaN）等概念，一般情况下用"=="是不会出错的，但是为了严谨起见，我们用包装类中的compare方法比较两个浮点数的大小。

   > Float.compare(float,float);
   >
   > - 返回值大于零，说明前面的参数大
   > - 返回值小于零，说明后面的参数大
   > - 返回值等于零，说明两个参数相等

3. BigDecimal类使用

   >1. 概述：不可变的，任意精度的有符号十进制数。
   >2. 成员方法：
   >   - 减法：BigDecimal subtract(BigDecimaol subtrahend);

# 五、hashCode方法

## 1.方法声明

`public native int hashCode();`

> 它是一个本地方法，但是它和getClass方法不同的是，它没有final修饰，可以被重写

## 2.方法的作用

1. 获取哈希值

2. 支持此方法是为了提高哈希表的性能。

3. Java中的hashCode方法表示一种哈希映射的规则，它把一个无限大小的集合（某个类的对象），映射到一个有限大小的集合。

   > 哈希
   >
   > 1. 概念：一种特殊的映射，映射不要求元素一一对应，允许出现多对一，但绝对不允许一对多。

## 3.hashCode实现

默认的Object类当中的哈希算法，是根据对象的地址计算出一个十进制int整数。如果对象的地址一样，那么它们的哈希值是一定相同的。

## 4.重写hashCode方法

> 常规协定
>
> 1. 在Java应用程序执行期间，在对同一对象多次调用hashCode方法时，必须一致的返回相同的整数（只要equals方法比较对象相等时的依据没有更改，那么它们的哈希值就一定相等）。
> 2. 从某一应用程序的一次执行到同一程序的另一次执行，该整数无需保持一致。因为在程序的另一次执行过程中，equals比较时所用的信息可能会更改。
> 3. **如果根据equals方法，两个对象是相等的，那么对这两个对象中的每个对象调用hashCode方法都必须生成相同的整数结果。**
> 4. <span style="background:yellow;color:red">equals方法和hashCode方法要么不重写，要么必须同时重写（而且重写依据必须一样）</span>
> 5. 如果根据equals方法，两个对象不相等，那么对这两个对象中的任一对象上调用hashCode方法不要求一定生成不同的整数结果。 

# 六、finalize方法（仅作了解）

# 七、clone方法

## 1.方法声明

`protected native Object clone() throws CloneNotSupportedException;`

> - 它是一个本地方法
> - 访问权限是protected：同包下任意访问；不同包下可以在子类中创建子类对象，然后访问，当然子类中可以选择重写访问权限
> - 返回值是一个Object对象

## 2.方法作用

得到一个完全独立的对象，并且成员（变量和方法）仍和原先对象一致。

> Object类当中的clone方法的实现，是一个本地方法，依赖于这个本地方法创建对象，它是一种完全独立于new对象的方式创建对象，它们之间是平行关系。

## 3.clone方法的使用

1. 首先就需要考虑访问权限，
   - 默认情况下，我们只能在子类中创建子类自身对象才能够调用clone方法
2. 一般情况下，我们直接使用clone方法在Object类中的默认实现就够了，不需要自己重写方法的实现。
   - Object类中的默认实现，克隆后的对象，一定和原先对象的类型是一致的。
   - 可以在子类中重写返回值类型，这样做方便后续的方法调用。（选做）
3. Java语法设计中，要想对一个对象做克隆操作，那么这个对象的类型必须实现接口Cloneable，否则会抛出异常 Clone Not Supported Exception（不支持克隆）。（必做）

<span style="background:yellow;color:red">总结：要想对对象做克隆操作，首先需要考虑权限问题，一般需要重写方法访问权限，接下来还需要这个类实现接口Cloneable，并且可以选做重写方法的返回值类型，因为Object类的clone默认实现一定会得到一个和原先对象类型一致的新对象。</span>

## 4.注意事项

1. **clone方法创建对象和new对象是独立的，平行创建对象的方式，相互没有关系。尤其注意clone方法创建对象，不需要使用构造器，它依赖本地方法创建对象。**

2. clone方法大多数情况下，没有重写的必要，使用Object类的实现足矣。但是如果想要重写，也是可以的，但总体需要遵循一定的原则：

   - 克隆后会得到一个新对象
   - 克隆后的对象一般不会改变数据类型，但如有必要也可以

3. Cloneable接口，实际上它是一个空接口，里面没有任何成员，没有抽象方法

   > 空接口的作用：
   >
   > - 一个类实现了一个空接口，表面上看没有得到任何成员，但是这个类的数据类型却发生了变化：从原先不是这个空接口的子类，变成了它的子类
   > - 于是可以配合instanceof关键字来做判断，并对应做出不同操作，
   > - 这种空接口实际上起着一种标记的作用，也就是常说的"标记接口"

4. Java当中的Object类的默认clone方法实现，是其拷贝的，浅克隆的；

   - 对象中的基本数据类型成员变量，完全拷贝一份，互相不受影响

   - 对象中的引用数据类型成员变量，只会拷贝一份引用，这个拷贝引用和原先的引用指向同一个对象。

     > 深度克隆需要在浅克隆的基础上完成，并且需要把对象中引用数据类型指向的引用再克隆一份，让拷贝引用指向拷贝对象，完成深度克隆。

