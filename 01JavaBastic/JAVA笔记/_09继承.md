[TOC]

# 一、属性隐藏

## 1.对象名点访问成员变量的访问机制

1. 访问范围

   > 1. 创建子类对象，用子类引用接收，访问范围：父类+子类
   > 2. 创建父类对象，用父类引用接收，访问范围：父类
   > 3. 创建子类对象，用父类引用接收，访问范围：父类
   >
   > 总结：对象名点成员变量，它的访问范围是根据引用的数据类型来决定的，和对象的具体类型无关。

2. 访问结果

   > 1. 创建子类对象，用子类来接收，结果：子类中的结果															
   > 2. 创建父类对象，用父类来接收，结果：父类中的结果
   > 3. 创建子类对象，用父类来接收，结果：父类中的结果
   >
   > 总结：对象名点成员变量，它的访问结果也是根据引用的数据类型来决定的，会体现出引用数据类型中的结果

**用对象名点访问成员变量，无论是访问范围，还是访问结果，都只需要看引用的类型即可，对象是什么无所谓**

# 二、方法覆盖

## 1.概述

- 覆盖不是物理意义上的覆盖，它肯定还是存在的，方法不过是方法去的二进制指令合集，类加载时期，装载进方法去，不会物理消失。对象名点访问成员方法，这个语法还是和访问成员变量有很大区别的。

## 2.调用机制

1. 访问范围

   > 根据引用的数据类型来决定

2. 访问结果

   > - 对象点成员方法的调用结果，是根据对象的具体类型来决定的。对于成员方法 的调用而言，
   > - 在代码的运行期间，JVM会自动根据对象的具体类型去找相应的方法，所以成员方法的调用结果是根据对象的具体类型来决定的，和引用无关
   
3. 方法重写

   - @Override，

   - 作用：放在子类重写父类方法的方法头上，用来判断这个方法是否重写子类。

   - 强调：在Java中，只要是重写父类的方法，必须用注解“@Override”标记

   - 语法：`[访问权限修饰符] 返回值类型 方法名（形参列表）{// 方法体； }`

   - 注意：

     > 1. 方法重写需要继承，所以必须发生在父子类当中的子类中
     > 2. 子类重写父类的方法，访问权限修饰符可以修改，但是只能改的更宽松，不能严格
     > 3. 返回值类型可以修改,父类的返回值类型是父类引用，子类的返回值可以是子类的引用。
     > 4. 方法名必须保持一致
     > 5. 形参列表必须保持完全一致

## 3.方法重载（overload），方法重写（override）

- 区别：
  1. 重载必须在一个类中，重写必须在两个类中
  2. 访问权限修饰符不影响重载，但是影响重写
  3. 返回值类型不影响重载，但影响重写
  4. 重载要求形参列表必须不同，但是重写要求必须相同
- 相同点：
  1. 方法名要求一致
  2. 都对方法体的实现没有要求

## 4.那些父类中的方法，不能被子类重写

1. 私有方法，虽然子类能够继承，但是不能没有访问权限，更不能重写
2. 静态方法，不能叫做继承，只不过是共用了父类的，既无法继承，更无法重写。
3. 构造方法，不能继承，更无法重写。

# 三、final关键字

## 1.修饰class类

- 概述：它表示这个类无法被子类继承了
- 语法：`[访问权限修饰符] final 类名{//类体；}`

## 2.修饰方法

- 概述：表示方法不能够被重写，但是方法继承仍然正常进行

## 3.修饰变量

- 三大原则

  1. 常量的分类
     - 字面值常量。"123"直接写在代码中的都是字面值常量
     - 自定义常量，就是final修饰的变量（命名规范：单词要全部大写，单词之间用_分隔）
  2. final修饰变量，仅表示变量的取值不可变，但是该变量原本在内存中存储位置，生命周期，使用方法等等不会发生改变
  3. final修饰变量，变量大的分类上有两种：
     - 基本数据类型，表示该变量的取值不再发生变化
     - 引用数据类型，final修饰的是引用，表示引用是一个常量，引用中存储的地址不再变化了，该引用不能再指向一个新的对象

- final修饰局部变量

  1. final修饰方法体中的局部变量：表示此变量初始化后不可修改
  2. final修饰方法的形参：表是该形参对应的实参，传入方法体后不可修改

- final修饰成员变量

  1. 要点：

     > - final修饰成员变量，表示成员变量，其取值一旦赋值，就不可更改了，而且 这个赋值一定要在创建对象的过程中赋值，不可在创建对象之后再赋值
     > - 直接写final修饰成员变量，语法会报错，所以成员变量的赋值不能依赖于默认初始化，只能在显式赋值，构造代码块，构造器三种赋值手段中三选一，也只能三选一。

- final修饰静态成员变量

  1. 要点：

     - 表示全局常量，是真正的一个常量，类全局唯一且取值不可变。
     - 这个赋值必须在类加载中完成，不能依赖于创建对象赋值。

  2. 语法：

     `[访问权限修饰符] final static 数据类型 变量名；`

     > 注： 
     >
     > 	1. static final还是final static都是可以，无所谓
     >
     >  	2. 一般建议全局常量，采用字母全部大写，下划线分隔单词的命名方法。

  3. 赋值：

     - 显然默认初始化不能作为全局常量的取值，所以只能：静态代码块赋值或者显式赋值，二者选其一，必须选其一，只能选其一

  4. 注意：

     - 访问全局常量，某些情况下，不会触发类的初始化（加载，链接，初始化，初始化用于执行静态代码块，执行静态成员变量的显式赋值）。如：**访问那些使用字面值常量赋值的全局常量，不会触发类的初始化，这个类的静态代码块不会执行。**
     - 原因：字面值赋值的全局常量，相当于字面值取个名字，本质上还是字面值，所以无需类加载，可以直接访问这个字面值，节省一次类加载的资源耗费。

- final修饰引用数据类型

  1. 要点：引用不可修改