[TOC]



# 一、封装（encapsulate）

## 1.概念：

- 封装是指将数据及相关操作绑定在一起的一种编程机制，使其构成一个不可分割的独立实体。将代码的使用者和实现者分开。
- 所以狭义上的封装，在java中指私有化成员变量，然后用必要的手段（方法）来与外界进行交互。

## 2.要求

- 具体：

  - 私有化成员变量后，一般是让外部绝对无法访问。但是即便外界有访问需求，任然建议私有化成员变量，然后提供相应的方法给外界使用。

  > 1. 如果外界想要访问，那就提供访问的方法，称之为"Getter"方法
  >
  >    - 语法格式：
  >
  >      `public 成员变量的数据类型 getXXX（）{return 成员变量名；}`
  >
  > 2. 如果外界想要赋值操作，那就提供赋值方法称之为“Setter”方法
  >
  >    - 语法格式：
  >
  >      `public void setXXX（成员变量的数据类型 成员变量名）{this.成员变量名 = 成员变量名}`

- why：

  1. 方法可以控制访问和赋值，这是对象名点访问做不到的
  2. 用方法以后，成员变量的访问和赋值分开操作了

- 注意：

  - 布尔类型的成员变量，getter方法一般写出isXxx的形式，如果布尔类型变量本身就叫isXxx，那么就会导致gette方法和成员变量的名字一样。

# 二、继承

## 1.概述

- 使用：Java中，在定义一个类时，可以显式的，直接的，使用“extend”关键字，表示继承某个类，继承某个类后，会得到该类的所有成员，完成复用成员的需求。
- 定义：**基于已存在的类创建新的类，这个新的类会得到已存在的类的成员，并且可以添加新的成员，从而让新的类适应新的开发需求。这就是继承。继承的本质是成员的复用。**

## 2.语法

`[访问权限修饰符] class 类名 extends 被继承类的类名{ // 类体； }`

- 子类和父类
- 子类继承父类后，会得到父类的所有成员，但继承一般不考虑静态成员，仅考虑普通成员（后面解释）
- 子类不光可以继承父类，得到父类成员，还可以自定义自身的成员。

## 3.继承中两个类的关系

1. 从属挂关系上来说，继承中的父子类具有"is-a"关系。子类可以近似地看成是一个父类，子类可以当作父类来使用。

   > - 从代码角度上来说，一个子类对象可以用父类的引用来接收。这样做，相当于把一个子类对象当成父类对象来使用
   > - 从数据类型的定义上来说，数据+操作就是数据类型。而对于引用数据数据类型来说，数据=成员变量，操作=成员方法，子类通过继承得到父类成员，子类可以当成父类
   > - 从功能上来说，子类的功能往往比父类功能更强。

## 4.继承层级

- 祖先类：处于继承顶层的类
- 继承层次（hierarchy）：由某个祖先类派生出来的所有类的集合叫做继承层次
- 继承链：从某一个子类开始，到其祖先类的路径
  - 不在一条继承链上的类，没有任何关系

## 5.继承的限制

1. 父类中的私有成员能够继承，可通过一个有权限的方法间接访问
2. 继承一般不考虑静态成员，父子类共用静态成员

## 6.扩充

1. 单继承：在Java中，一个类无法直接使用extends关键字继承多个类
2. 一个类如果没有写extends关键字，那么它就继承Object，

# 三、引用数据类型的类型转换

## 1.转换条件

- 引用数据类型的类型转换，转换的都是引用的数据类型，对象的数据类型是不可能转换的。

- 必须存在继承，继承中的父子关系的两个类才能发生引用数据类型的类型转换

## 2.自动类型转换（向上转型）

- 原理：编译器自动完成，无需写额外代码
- 条件：把子类引用转换为父类引用，这个过程编译器自动完成
- 为什么：子类"is-a"父类

## 3.强制类型转换（向下转型）

- 原理：程序员手动，需要写代码
- 条件：把父类引用转换成子类引用，这个过程需要程序员写代码强制编译器做类型转换
- 语法：`子类类名 对象名 = （子类类名）父类引用；`
- why:因为父类不能看成子类，子类往往比父类强大；绝大多数情况下都是不可能的，所以引用数据类型的强制类型转换想要完成，条件会更加苛刻。

# 四、protected关键字

## 1.访问权限

- 同包下任意访问，不论是不是该类的子类

- 不同包下，必须在子类中才能够访问。

  > 访问方式：
  >
  > 1. 创建父类对象访问该protected成员
  >    - 在不同包下的子类，不能访问父类对象中的protected成员
  > 2. 创建子类对象，访问子类继承自父类的protected成员
  >    - 可以访问，在不同包下的子类中，可以创建子类自身对象，访问子类继承自父类的protected成员
  > 3. 创建“兄弟姐妹”对象，访问它们从父类继承过来的proctected成员
  >    - 不能

- 总结：<span style="background:yellow;color:red">protected成员在不同包下，必须在子类中创建子类自身对象，才能够访问从父类中继承过来的受保护成员，其余方式都不行。</span>

# 五、子类对象初始化

## 1.步骤

1. 首先类加载，创建子类对象，或者出发子类的类加载，应该先类加载它的父类；而且如果父类还有父类，那么会优先加载顶层父类。
2. 类加载结束后，开始创建对象，要明确只会创建一个对象，就是子类对象，不会创建父类对象。
3. 子类对象当中需要开辟空间存储父类的成员变量和自身的成员变量。单独开辟一片独属于父类的区域，用于存放父类的成员变量（super关键字指向）。
4. 子类成员变量和父类成员变量的赋值先后顺序是“先父后子”；
5. 两种子类对象初始化方式：
   - <span style="background:yellow;color:red">子对象的隐式初始化：在java中，任何一个类的任何构造器中（包括默认提供的无参构造器），只要第一行没有使用this或者super去调用其他构造器，永远隐含一行代码：`super（）；`表示调用父类的无参构造器，</span>这样子类对象的初始化，永远执行父类构造器，父类成员变量的赋值永远先于子类
   - 显然子类对象的隐式初始化调用父类的无参构造器，无法给父类成员变量赋值。 如果在子类创建时，有给父类成员赋值的需求，就必须显式的调用父类的有参构造器；这样就必须在子类构造器的第一行写：`super（实参列表）；`

## 2.注意事项：

- 子类对象在创建时，只会创建子类对象，这个过程中，虽然父类的构造器执行了，但构造器本身的作用就是在创建对象过程中赋值，子类构造器给自身成员赋值，父类构造器给父类成员赋值，这个过程不会创建父类对象。
- **子类对象的隐式初始化依赖于父类的无参构造器，如果父类没有无参构造器，那么子类就不能隐式初始化；**必须显式初始化，必须直接的调用父类的某个有参构造器，否则会编译报错。
- super关键字和this关键字，表示调用构造器时，必须在第一行代码

## 3.super和this

1. 相似点
   - super点调用父类的成员方法，访问属性。只有在父子类成员同名时，可以用来做区分
   - 在构造器中，super可以调用父类构造器方法
2. 不同点
   - this表示自身对象当前对象，访问不受权限限制，但super终究是父类的，所有它受访问权限
   - this确定是一个引用，它确实指向一个子类对象，所以在方法中可以直接输出它，因为它就是一个引用，装的是对象的地址。super终究不是一个引用，它指向的不是对象，而是对象中的一片区域，所有super不能打印。