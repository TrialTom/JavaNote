[TOC]

### 一.对象和类的概述

- #### 对象：
  
  - 面向对象程序世界中，对象是程序的基本组成单元，程序是由很多个对象共同组成的。对象独立存在，具有属性和行为
  - 属性：个体的状态信息（数据）	
  - 行为：个体能够做什么（操作）
  
- #### 类：
  
  - 创建对象的模板就是类（class）
  - 类抽取了同类别的所有对象属性和行为上的共性。
  - 类是抽象的模板，对象是具体存在的个体（实例）

### 二、类的创建和使用

1. #### 语法：

   > 【各种修饰符】	class 类名{
   >
   > ​	//类体
   >
   > }
   >
   > - 能够修饰类class的修饰符有很多，主要包括访问权限修饰符，final等，也可以不写任何修饰符，是一个非public修饰的class
   > - 一个JAVA文件下，所有的clas都是同包的关系，而同包下不能有同类
   > - 正常情况下，两个类如果定义在同一个java文件下，是相互独立的，但是java中的类是可以嵌套定义的，称之为内部类。

2. #### 定义类中的结构

   - 类是模板，抽取了该类型全体对象的属性和行为上的共性，用于描述全体对象。类中使用**成员变量（member variable）**来描述全体对象属性上的共性。

   - 成员变量的定义语法

     > [各种修饰符] 数据类型 成员变量名；

   - 成员方法：定义在成员位置，并且没有static修饰的一个方法

     > [访问权限修饰符] 返回值类型 方法名（形参列表）{
     >
     > //方法体
     >
     > }

3. #### 创建对象

   - 创建对象的位置：普遍来说，应该在一个方法中创建对象（当然其他位置也不是不行）

   - 创建对象需要的前提：必须要具有这个类的访问权限，才能创建这个类的对象。对象创建完毕后，就可以使用对象来访问成员变量，调用成员方法。

   - 语法：

     > - 创建
     >
     >   类名 对象名 = new 类名（）；
     >
     > - 成员变量的访问语法：
     >
     >   对象名.成员变量名
     >
     > - 成员方法的调用语法：
     >
     >   对象名. 成员方法名（实参）；
     >
     > <span style="background:yellow;color:red">**对象中的成员变量，类似于数组中的元素，它的取值具有默认初始化的步骤，具有默认值。而且默认值是永远的第一步,不可省略。**</span>
     >
     > 成员方法中，是可以去访问自身类的成员变量的，对象名.成员变量可以获取该成员变量的取值，也可以用于成员变量的赋值

### 三、引用数据类型

1. #### 类加载

   > 在Java中，把jvm认识了解一个类型的过程，称之为类加载
   >
   > - 类加载是通过把某个类的二进制字节码文件（class文件）通过IO流的形式，读取进JVM内存中的方法区实现。
   > - JVM通过类加载，了解该类的类型信息，于是就可以开始创建这个类的对象了。
   > - <span style="background:yellow">**类加载的设计原则是“懒加载”，只有到非类加载不可，不类加载该类，程序就无法运行时，JVM才会类加载某个类，这是为了保证程序的运行效率。我们把一定会加载某个类的场景，称之为“类加载的时机”**</span>

### 四、局部变量和成员变量的区别

1. #### 在类中定义的位置不同
   
   - 成员变量：定义在成员位置，指的时类体中，局部位置以外
   - 局部变量：方法中或者是一个作用域内部
2. #### 在内存中的位置不同
   
   - 成员变量：堆上的对象中
   - 局部变量：方法的栈帧中
3. #### 生命周期不同
   
   - 成员变量：和对象同生共死，
   - 局部变量，和方法调用同生共死
4. #### 有无默认初始化
   
   - 成员变量：是有默认初始化的，是具有默认值的
   - 局部变量：没有默认初始化，没有默认值，必须手动初始化，必须手动赋值
5. #### 作用范围
   
   - 成员变量：在整个类的成员方法中，都是可以使用的；但是在类中的static修饰的方法中，是不能访问成员变量的。除此之外，类中的成员方法可以相互调用，static方法也可以互相调用
   - 局部变量：被大括号限制了作用域

### 五、this关键字

1. #### 存在同名的方法局部变量和成员变量时，他们两个变量都是可以匹配的，这时要考虑“就近原则”。

2. #### this关键字：

   > 在一个类中的每个成员方法中，方法的形参列表中，总是隐含了一个隐式的传参，这个参数就是这个类的对象，就是当前对象，这个对象用引用“this”指向它，this指向当前对象，然后作为一个隐式传参，作为该成员方法的一个隐式形参。
   >
   > - this关键字的作用：
   >   1. 用来区分同名的成员变量和局部变量
   >   2. 类中每个成员方法的形参中，总是隐含this传参，所以成员方法中可以无条件访问类中的其他成员方法和成员变量，
   >   3. 代码比较复杂，用this.访问成员变量或者成员方法，可以提升一定的代码可读性
   > - static修饰的静态方法，是不能直接访问成员变量的，这是因为static方法中没有隐含的this传参，static方法中没有当前对象，所以不能传参。

### 六、构造器（constructor）

1. #### 使用构造器（构造方法），灵活地给成员变量赋值

2. #### 构造器的语法：

   > [访问权限修饰符] 类名（形参）{
   >
   > //构造方法的方法体
   >
   > }
   >
   > - 首先构造器必须写在类体，它是一个特殊的方法
   > - 访问权限修饰符默认用public
   > - 构造器语法中的类名处在普通方法的返回值类型的位置，说明构造方法是没有返回值的，构造器也不需要返回值类型。这里的类名可以认为是构造器的名字，构造器的名字和类名保持完全一致
   > - 形参列表和方法体，与普通方法没有区别

3. #### 特点：

   - 构造方法不是给程序员调用的，而是JVM在创建对象过程中，自动调用的，构造器的作用是，在创建对象过程中，完成给成员变量的赋值工作。

   - 构造器虽然程序员不可以直接调用，但我们可以指示JVM创建对象时，用哪个构造器完成成员变量赋值

     > 语法：new 类名（形参列表）；
     >
     > 其中new 关键字表示创建对象，类名（实参） 其实就对相应构造器的名字和形参。

   - Java中任何一个类，如果没有直接在类中写一个构造器，那么就默认提供一个无参构造，称之为默认无参。默认无参构造器的方法体是空的，是不能给任何成员变量赋值的，所以如果想要构造器完成成员变量的赋值，需要提供有参构造器。

   - <span style="background:yellow">构造器中任然隐含有this传参指向当前对象。</span>

   - <span style="background:yellow">成员变量的赋值方式虽然有很多中，但是永远的最后一步，是构造器。</span>

   - <span style="background:yellow">默认无参只有在一个类没有任何构造器时提供，一旦这个类有任何一个构造器，默认无参就没有了。</span>

4. #### 类加载和构造器的执行

   - new对象几次，对应的构造器就会执行几次，
   - 类加载只有一次，在首次触发类加载时执行。

5. #### 构造器的作用是在创建对象的过程中，给成员变量赋值的，不要认为构造器就是用来创建对象的。

### 七、包装类

1. #### 概念：

   Integer是int类型的包装类型，包装类就是把基本数据类型包装成引用数据类型，变成一个个对象。

   > java当中的基本数据类型数值整型，它们的取值范围都不是一个数轴，而是一个圆环，都是首尾相接的

2. #### 特点：

   - 最重要的特点，“自动拆装箱”，基本数据类型和它的包装类在大部分情况下可以混用
   - 包装类中存在和对应类型相关的一些常用属性，比如最大值，最小值
   - 包装类中还存在和对应类型相关的一些常用操作，比如进制转换，类型转换（paresxxx）等

3. #### 使用场景：

   - 在不太方便使用基本数据类型，但又确实需要一个对应变量时，使用它的包装类型
   - 集合（容器）是不允许装基本数据类型的，可以在集合中使用对应的包装类存储基本数据类型

4. #### 注意事项：

   - 包装类始终是一个类，是一个引用数据类型，始终是不同的基本数据类型。使用包装类要注意空指针异常。
   - 包装类在比较数值大小时，不能再像基本数据类型一样用“==”比较，而是使用equals方法
   - <span style="background:yellow;color:red">对于整型的包装类型对象，是存在缓存数组，在一个byte取值范围内的，包装类型对象都是在缓存数组中，预先定义好了，一旦要使用，就直接从cache中取出来，所以整型包装类型对象，它的取值范围只要在[-128~128]之间，它们是共用缓存中的对象</span>

5. #### 包装类型是怎么包装的？

   - 包装类型对象当中会存储一个对应类型的基本数据类型成员变量。

     > 比如Integer当中就有成员变量：private final int value；
     >
     > final关键字表示一个常量，这就意味着这个对象一旦创建出来了，那么对象当中的value数据就是不可变的。
     >
     > - <span style="background:yellow;color:red">一个对象一旦创建完毕，除非销毁它，不然不能改变value的数值；如果引用需要改变value数值，需要指向一个新的对象（新的对象是可以创建出来的，也可以从缓存中取（取决于范围））</span>

### 八、static关键字

1. #### 概述：

   - static关键可修饰成员变量，表示静态变量，使得全体对象共享某个存储空间的变量

2. #### 语法：

   > [访问权限符] static 数据类型 变量名；
   >
   > 静态成员变量属于类，所以禁止使用对象名.访问静态成员变量（虽然这样确实可以访问），应该使用类名.访问。
   >
   > - static也同样可以用来修饰成员方法，称之为静态成员方法；静态成员方法同样属于类，在调用时需要使用类名.调用，禁止使用对象名点调用。
   > - 特殊的，如果是在同类中的static方法之间互相调用可以省略类名，直接使用方法调用。
   > - 跨类调用静态成员方法，是不可用省略类名的，当然，也可以不论是否跨类，都是用类名点调用静态成员方法，这有助于代码可读性。
   > - static修饰的静态成员（包括类和方法）都是属于类的，static修饰的静态成员的使用，完全不依赖于创建对象的过程，而是依赖类加载。

   > - 类加载的过程先于创建对象的，只要类加载完毕一个类，类中的静态成员变量就可以使用了。类加载过程中，给静态成员变量开辟内存空间，然后完成赋值；类加载过程中，加载静态成员方法的指令，类加载结束，这个静态方法就可以调用了。
   > - 类加载在运行时进行，通过ClassLoader类进行

3. #### 使用场景

   - 静态成员变量属于全体对象所共享而不是独属于某个对下那个的成员变量，
     - 当存在需要所有对象共享的变量时，应该使用static
     - 不仅时全体对象共享的，而且是整个类全局独一份的（类加载只有一次）

