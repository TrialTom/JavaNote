[TOC]



# 一、method（方法）

## 1.本质就是代码复用

> 1. 能够重复实现某种特定功能，解决同一类问题，而不需要重复写代码
>    - 把方法在使用并解决需求的过程，称之为方法调用（invoke）
> 2. 每次实现这个功能时，可以传入不同的数据
> 3. 传入数据实现功能后，能够得到不同的结果

## 2.语法

[修饰符列表]	返回值类型	方法名（形参列表）{

​		//方法体

}

> 1. 修饰符列表：能够使用的修饰符有很多，我们总是默认方法的修饰符是public static，当然修饰符列表对于方法而言，不是必须的，完全可以省略什么都不写
> 2. 返回值类型：方法调用结束，返回的结果的数据类型，可以是基本数据类型，也可以是引用数据类型
> 3. 方法名：他是一个标识符，遵循“小驼峰式”的命名规范，尽量用动词
> 4. 形参列表：(数据类型 形式参数名)
>    - 形参是占位符，写在方法声明中，不是一个真正的参数，可以在方法中被使用，表示方法的参数传入后的使用方式
>    - 实参是一个真正的参数，在方法调用时，传入方法
> 5. 方法体：实现功能，需要执行的语句集合

- 我们把**“[修饰符列表]	返回值类型	方法名（形参列表）”**称之为方法头或者方法声明
- 我们把**“方法名（形参列表）”**称之为方法签名

## 3.方法定义的位置：

- 首先必须在类体中，其次必须定义在其他方法的外部

- 方法是不能嵌套定义的

## 4.方法的调用

- main方法是程序的入口方法，其他方法要想被调用就必须直接地或者间接地在main方法中调用

> 1. 在同一个类中，在main方法中，调用同类中的static修饰的方法，调用方式是：
>
>    方法名（实参列表）：
>
> 2. 

## 5.其他细节

- Java中的一个类中的方法，是平行关系，位置不同，不会影响方法调用的结果
- 同类中static 和static修饰的方法之间可以相互调用，直接用方法名调用即可

- <font color=red>**方法调用时，实参数据类型和形参数据类型时存在自动类型转换的。**</font>
- 返回值和它的返回值类型也存在自动类型转换

# 二、main方法解释

1. 方法头：
   - public static 表示main方法是**“公共的，静态的”**是修饰符列表
   - void表示main方法没有返回值
   - main是一个方法名，不是关键字，但是一个约定俗称的程序入口，一般也不建议程序员写代码用main
   - String[] ：表示一个String类型的数组
   - args是形参的名字
   - add，subtract，multiply，divide，square，Math.pow()

# 三、方法的使用场景

- 两种常用的使用场景
  1. 复用代码，避免代码冗余（idea中快速提取方法的快捷键：ctrl + alt + m）
  2. 方法的代码过长，会影响代码的可读性；过长保留骨干逻辑，提取分支作为一个独立的方法

# 四、方法重载

1. 概念：允许一个类中，多个方法拥有相同的名字，
2. 方法重载的条件：形参列表必须不一样（有且仅有以下几种）
   - 形参的数量不同
   - 形参的数量相同，数据类型不同
   - 形参的数量相同，数据类型也相同，数据类型位置不同
3. 调用重载方法的原则
   - 由实参的数据类型决定
   - 就近原则：在Java 的语法设计中，如果同时存在多种情况都能匹配，那么有限选择“最近的”，拿方法调用来说，最近指的是，恰好匹配数据类型，或者最近的自动数据类型转换

# 五、Junit单元测试

1. 概念：junit可以实现在一个类中多个main方法的效果

2. Junit的使用：

   > 1. <span style="background:yellow">首先要创建一个类，而且这个类最好不要叫Test</span>
   > 2. <span style="background:yellow">然后在这个类的<font color=red>**类体中，方法外面，**</font>写注解@Test</span>
   >    - 注解，annotation，他是一种和class同等级别的数据类型，使用应用数据类型
   >    - “@Test”当中，其中Test是这个注解的名字，相当于类名
   >    - “@”加上这个注解名，表示创建这个注解的对象（这是一种独特的创建对象方式）
   >    - “@Test”注解是Junit的一个基本注解，它表示创建一个测试方法，这个测试相当于main方法
   > 3. <span style="background:yellow">直接写注解肯定会报错，原因：缺少导包的步骤</span>
   >    - 注解@Test和Scanner导包有所不同，Scanner是JDK中原本就存在的类，可以直接导包
   >    - 注解@Test不是JDK中已经存在的注解，而是第三方开发出来的工具当中的注解
   >    - 需要一个将第三方工具包导入当前工程的过程，称之为<font color=red>**“导入依赖”**</font>。正常情况下，依赖导入需要通过依赖管理工具（Maven）去导入，或者手动导入
   >    - 但是Junit这个第三方依赖很特殊，它的依赖包已经存在于IDEA本地文件中，可以通过<span style="background:yellow;color:red">“alt + 回车”</span>导入依赖，并完成导包
   > 4. <span style="background:yellow">写完注解后，还需要写测试方法，格式：</span>
   >    - public	void	方法名（）{	// 方法体}

3. 注意事项

   - 一个类中如果存在Junit后，就不建议再写main方法
   - Junit单元测试注解@Test的测试方法，它的格式是固定的，除了方法名字和方法体，其他地方一般不修改。

# <font color=red>六、为什么Junit的使用最好不要在一个Test类中</font>

> 由于Junit的测试方法需要使用注解@Test，其中Test是注解的名字，相当于类名，<span style="background:yellow;color:red">**而注解和类是同等级别的数据类型**</span>，所以如果直接在Test类中，写注解@Test，会优先选择使用自生类Test作为一个注解，但是Test本身就不是注解，而且也不是我们想要的那个注解Test。
>
> **这也是一种就近原则**
>
> - 解决方案：
>
>   在写注解时，带上包名（由于Java中同包下绝对不可能存在同名类）
>
>   格式：包名+类名（注解名，<span style="background:yellow;color:red">**全限定类名**</span>）---> @org.junit.Test

- 单元测试最重要的，最具有使用价值的用途是用来写单元测试代码，提升工程的单元测试覆盖率

# 七、Debug

- force step into：强行进入（方法）

> JDk中源码中的方法才需要强行进入

- Variables窗口查看