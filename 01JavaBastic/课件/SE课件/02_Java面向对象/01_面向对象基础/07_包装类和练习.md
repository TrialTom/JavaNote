[TOC]

# 前言

> `>(green)`
>
> 学到这里，面向对象的最最基本知识你已经有所了解了。在这里，我们做一些练习，并且引申讲解包装类。

# 对象与类语法练习

> `>(red)`
>
> 完成以下案例，思考一下怎么能够找到系统中类、对象究竟是哪些？
>
> 1. 用面向对象的思想模拟LOL当中盖伦的战斗
> 2. 用面向对象的思想模拟植物大战僵尸
>
> ---
>
> > 如何从需求中找到对象和类？
>
> - 对象往往都是实体，一般都是名词。
> - 抽取出对象的共性特征，也就是成员变量和方法，就可以定义一个类。
>
> 注意事项：
>
> 1. 对象之间如果需要交互，可以考虑持有对方的引用作为成员变量。
> 2. 日常开发中，不建议随便把很多类定义在同一个Java文件中。正确情况下，建议一个Java文件定义一个public修饰的类，当然如确有需求，也可以定义非public class。
> 3. 一个Java文件下的所有类，属于同包关系。

# 值传递练习

> `>(red)`
>
> 学习对象与类后，再复习一下如果方法的参数是需要一个对象，值传递是怎样进行的。
>
> > 练习：
> > 定义一个学生类，该类具有一个int属性age
> >  1.在测试类中写一个方法，交换两个Student对象的age属性
> >  		请问能够交换成功吗？原因是什么？
> >
> >  2.在测试类中写一个方法，交换两个Student对象的引用（地址）
> >  		请问能够交换成功吗？原因是什么？
>
> 结论：
>
> 1. Java只有值传递
> 2. Java当中的方法可以改变对象的状态（成员变量的取值）但是无法直接交换两个引用（无法改变局部变量）



# 一些奇思妙想

> `>(green)`
>
> 这里需要研究两个问题。

## 构造方法的命名

> `>(red)`
>
> 构造方法的名字必须和类名一模一样吗？
>
> 显然是需要一样，构造方法必须和类名一致就是定义。
>
> 那么我类名的书写不规范，比如没有用大驼峰，那么就会连带着构造器的命名也会出现问题，参考以下代码：
>
> ###### 规范命名重要性
>
> ``` java
> //构造器
> public stuent(){
> }
> //创建对象语法
> student student = new student();
> ```
>
> 以上的书写方式显然是可笑的，成熟的Java程序员会在看到小驼峰命名的标识符时，下意识的觉得：
>
> 1. 它可能是一个方法（如果后面带括号）
> 2. 它可能是一个变量（如果后面没有括号）
>
> 但是，我相信他一般都不会联想到它居然会是一个类class。
>
> **命名不规范是程序员之间的严重的减分行为，会让人觉得你水平低下，不靠谱。优秀的程序员应该永远注重细节，永远细心，这样才能写出严谨且bug较少稳定的代码。**

## 普通方法的命名

> `>(green)`
>
> 普通方法在命名时，允许和类名一样吗？
>
> 从语法角度来说，Java语法并未限制一个普通方法的名字和类名不同，也就是说普通方法在命名时，允许和类名保持一致。
>
> 但是这么书写，IDEA会给我们提示警告信息，所以我们不要这么做：
>
> 1. **方法名和类名保持一致，是构造器的专属。**
> 2. 普通方法不应该这么使用，普通方法和类名保持一致是不合适的。

# 包装类与debug模式

> `>(green)`
>
> 查看下列代码，请回答下列代码的执行结果是什么？
>
> ###### 包装类相关引例
>
> ``` java
> int end = Integer.MAX_VALUE;
> int start = end - 5;
> 
> public static void main(String[] args) {
> int count = 0;
> for (int i = start; i <= end; i++){
> 		count++;
> 	 }
> System.out.println(count);
> }
> ```
>
> 首先查看一个经典报错：
>
> > Non-static field 'start' cannot be referenced from a static context
>
> 意译过来，就是在一个静态（static）的方法中无法访问一个非静态的成员变量。
>
> 在我们没有学习static关键字之前，先记住static方法中，只能访问static修饰的成员变量和方法。
>
> <span style=color:red;background:yellow>**当然，若想在static方法中访问成员变量，那么这个成员变量也一定是static修饰的！！**</span>
>
> ---
>
> 有符号数的最大值：
>
> > 1. Integer.MAX_VALUE的二进制是0111 1111 1111 1111 1111 1111 1111 1111
> > 2. Integer.MIN_VALUE的二进制是 1000 0000 0000 0000 0000 0000 0000 0000
> > 3. Integer.MAX_VALUE + 1 = Integer.MIN_VALUE
>
> 所以很明显，上述代码，循环会从int类型最大值循环到int类型最小值，再循环到int类型最大值....**显然，这是一个死循环！**
>
> 当然，让这个代码不死循环也很简单，只需要修改循环条件即可。

## 包装类

### 基本定义

> `>(red)`
>
> 什么是包装类？
>
> 大家都知道：Java是面向对象的语言，Java当中万物皆对象。
>
> 但这句话并不严谨，因为Java不是完全面向对象的编程语言。**因为Java还有基本数据类型变量，它们不是对象。**
>
> 所以为了弥补基本数据类型变量非对象的尴尬境地，并且我们确有需求把基本数据类型变量也当成一个对象使用，Java引入<font color=red>**包装类**</font>的技术。
>
> **所谓包装类，就是把基本数据类型包装成引用数据类型，变成一个个对象。**
>
> 以下包装类和基本数据类型对应关系：
>
> ###### 包装类型对照表
>
> | 基本数据类型 |       对应包装类        |
> | :----------: | :---------------------: |
> |   **byte**   |   **java.lang.Byte**    |
> |  **short**   |   **java.lang.Short**   |
> |   **int**    |  **java.lang.Integer**  |
> |   **long**   |   **java.lang.Long**    |
> |  **float**   |   **java.lang.Float**   |
> |  **double**  |  **java.lang.Double**   |
> | **boolean**  |  **java.lang.Boolean**  |
> |   **char**   | **java.lang.Character** |
>
> **除此之外，还有一个比较独特的包装类型：返回值类型中的void对应包装类型Void，仅作了解。**



### 特点

> `>(green)`
>
>  <font color=red>**包装类有什么特点呢？**</font>
>
> > 1. 在Java当中，把基本数据类型变量，转换为其对应包装类的引用数据类型变量，称之为"装箱"
> > 2. 在Java当中，把包装类的引用数据类型类型变量，转换为其对应基本数据类型变量，称之为"拆箱"
>
> Java中的"拆箱"和"装箱"都是自动进行的，基本数据类型变量和它的包装类引用数据类型变量，可以自由、自动的互相转换。
>
> **注：自动拆装箱，实际上是依赖于底层自动调用方法去实现的。感兴趣可以自行搜索学习一下。**
>
> <font color=red>**自动拆装箱意味着，多数情况下，基本数据类型和它的包装类可以混用（当然也有不能混用的情况）**</font>

### 用途

> `>(green)`
>
> 包装类总结起来，大致有以下四个应用场景：
>
> 1. 包装类把基本数据类型变为一个对象，并且存在自动拆装箱，有些时候这本身就是一个用途。
> 2. 包装类当中包含了其对应基本类型的相关属性，如最大值，最小值，所占位数等等。
> 3. 包装类作为基本数据类型对应的引用数据类型，提供了一系列实用的对象操作，如类型转换，进制转换等
> 4. **特殊的，集合（容器）中是不允许装基本数据类型的，可以在集合中使用对应的包装类存储基本数据类型。**

### 注意事项

> `>(green)`
>
> 包装类始终是一个类，它是一个引用数据类型，始终是不同于基本数据类型的，所以要注意以下：
>
> 1. 使用包装类要注意空指针异常，而基本数据类型没有这个烦恼。
> 2. **包装类对象在比较数值大小时，不能再像基本数据类型一样用"=="比较了！而是要使用"equals"方法。**

###### The End
