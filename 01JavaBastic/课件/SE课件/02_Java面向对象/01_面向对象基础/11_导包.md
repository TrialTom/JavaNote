###### <sub><font color = orange>JAVASE基础教程</font></sub><br />——<br /><sup><font color=white>卷1</font></sup><font color=white>面向对象基础</font><br/><sup><sub><font color=cyan>节11</font></sub><font color=cyan>导包</font></sup><br/><br/>	``#最新版本|V2.0#(purple) ``<br/>**长风**<br/>*COPYRIGHT ⓒ 2021. 王道版权所有*

[TOC]

# 概述

> `>(green)`
>
> 我们已经很早接触过导包的概念了（Scanner），这一节，详细的了解一下导包的概念。主要讲解两个关键字： <font color=red>**package和import**</font>

# package关键字

> `>(green)`
>
> package这个关键字我们并不陌生，它写在Java源文件的第一行，**用于声明整个Java文件下的所有类的所属包。**
>
> 语法：
>
> ``` java
> package + 包名
> ```
>
> 当然，一个Java源文件当中，只能有一个public修饰的类。其余**非public修饰的类和public类都属于同包的关系。**

> `>(red)`
>
> package关键字的使用很简单，但是有几个需要注意的地方：：
>
> 1. 包名在书写时，如果存在多级包名，需要使用用逗号隔开
> 2. package声明必须处在**一个Java文件有效代码**的第一行，否则会报错
>    - 注释不算有效代码，将package声明放在注释下面也是可以的
>    - 建议**将package声明永远放在Java源文件真正意义上的第一行**
> 3. 多数情况下，我们使用idea新建Java文件是无需关系package声明的，因为idea会自动生成
>    - 但是当你从网上或者其它途径弄到的一些代码，可能会出现包名错乱的情况
>    - **这时建议直接删除package声明，然后alt + 回车类名报错的地方即可**

# 全限定类名

> `>(green)`
>
> > 什么是全限定类名？
>
> 1. 可以**唯一的、准确的定位到一个类**的，由包名加上类名组成的字符串，就是全限定类名
> 2. 不做任何操作的情况下，直接输出一个对象的引用，会打印全限定类名

# import关键字

> `>(green)`
>
> import关键字很简单，和它单词的意思一样，就表示导入的功能。但实际使用，还是有一些细节上的问题。

## 引例

> `>(green)`
>
> 请按照以下步骤创建需要的类：
>
> 1. 在包名为**one**的包中创建一个**public class Student**和测试类**public class Demo**
> 2. 在包名为**another**的包中创建一个**public class Student**和**public class Teacher**
> 3. 在同名的Student类中给出同名的方法test，并给出不同的实现
> 4. 创建完毕后，开始进行测试工作
>
> 请完成下面测试：
>
> > 1.在Demo类中直接创建Student对象，然后调用test方法，请问输出的结果是什么？
> > 2.如果想要test方法调用得出anotherpackage包中Student类的结果，需要怎么做？
>
> 显然，在Test类中直接创建Student类对象时，test方法的调用结果是onepackage下Student类的方法，而如果想要test方法的调用结果体现为anotherpackage包，就需要使用import关键字进行导包操作~

## 作用

> `>(green)`
>
> 从上述案例中，我们可以总结一下编译器在**查找并决定使用某个class**时，它的搜索机制：
>
> 1. 在同包下时，类名是绝对唯一的，有就有，没有就没有，不存在选择的问题。
>    - 这时，编译器是可以直接通过一个类名去查找到一个类的，不需要额外操作，不需要导包。
> 2. 当同包下没有这个类，必须在不同包下寻找时， <font color=red>**多个不同包中完全可能存在同名类**</font>
>    - 这时，编译器肯定是不可能直接通过类名去查找一个类了，需要**程序员手动导包。**
>    - 手动导包的目的是**明确告诉编译器应该使用哪个包下的类。**
>
> ---
>
> **使用import关键字手动导包的语法是：**
>
> ``` java
> import 全限定类名;
> ```
>
> 注意事项：
>
> 1. import导包语句应该放在**package声明之后，有效代码之前。**
>
>    - 正常情况下，我们使用某个类idea会自动导包，不用太关心这条语句的位置（当然你也不能手动修改，乱写。）
>
> 2. 像String、System、Math等常用类很明显不是同包下的类，但我们并没有进行导包操作
>
>    - 这是因为在Java当中，java.lang包是Java的核心类包，具有隐式的导包
>    - **注意java.lang包下的所有类是隐式的导入了每个Java类，而不是没有导入！**
>
> 3. 实际上完全可以不导包去使用不同包下类，这时要明确指出这个类的所属包，也就是要使用全限定类名。
>
>    但是一般情况下，全限定类名都很长，导包仍然是更好的手段。
>
> 4. 但是导包总不是都好用，在极少的情况下：比如在Demo类中如果想要同时访问两个包onepackage、anotherpackage下的两个Student类，就需要一个Student类使用全限定类名，另一个导包或者就近原则直接使用。（当然条件允许的情况下，干脆把其中一个Studnet改名会更好。）

## 智能导入

> `>(green)`
>
> > import关键字存在智能导包的形式，会智能的**<font color=red>根据需要</font>**导入需要的某个**类**
>
> 它的语法是这样的：
>
> ```java 
> import + 包名.*;
> ```
>
> 其中“ * ”具有通配的含义，表示该包的类都会根据需要导入。智能导包是一种十分高效且方便的导包方式， <font color=red>**其使用的重点在于理解：何为需要！**</font>
>
> 即：需要指的是**不导入对应包下的类就会报错，不导入不行。反之如果同包下有同名类则不会导入）**
>
> 例如：
>
> ​		 <span style=color:red;background:yellow>**同包中已存在Student类，再想通过智能导包导入别的包下的Student类是无法完成的。**</span>

## 静态导入

> `>(green)`
>
> > import还可以和static一起使用，称之为静态导入
>
> 它的语法是：
>
> ###### 静态导入的语法
>
> ```Java
> import static 全限定类名.*;
> import static 全限定类名.静态成员;
> ```
>
> **普通import导入导入的是某个类，而静态导入导入的是静态成员（变量和方法）**
>
> > 以往我们访问不同包下的类的静态成员，是通过类名.静态成员名的形式访问的
> >
> > 而如果使用静态导入的语法将这些不同包的类当中的静态成员导入，就可以省略相应的类名~
>
> 例如对于静态导入代码：
>
> ```Java
> import static java.lang.System.out;
> ```
>
> 就可以在main方法中写出以下代码：
>
> ```Java
> out.println("Hello World!");
> ```
>
> 智能导入也有类似的作用：
>
> 例如：
>
> ```Java
> import static java.lang.Math.*;
> ```
>
> 就可以写出以下代码：
>
> ```Java
> double a = PI;
> double b = pow(2,3);
> ```
>
> 静态导入简单了解有这个语法就可以了，静态成员在访问时本就更推荐加上类名，以增加代码可读性。现在使用静态导入后，不仅不加类名了，更是颠覆了常规的代码形式，让代码看起来很奇怪。**所以实际开发中它是非常罕见的语法，大家也尽量不要在自己的代码中使用~**
>

## 编译单元导致的错误

> `>(green)`
>
> > 接上述案例：
> >
> > 1. 在包名为**onepackage**的包中创建一个**public class Student**和测试类**public class Demo**
> >
> > 2. 在包名为**anotherpackage**的包中创建一个**public class Student**和**public class Teacher**
> >
> > 3. 在同名的Studet类中给出同名的方法test，并给出不同的实现。
> >
> >    请完成以下测试：
> >
> > **在测试类Demo.java文件下创建一个非public的class Teacher，然后在Demo类中创建Teacher对象。**
>
> 由于就近原则的存在，上述操作得到的对象肯定是onepackage包下的Teacher对象，那么这时如果想要通过导包创建anotherpackage包下的Teacher对象能够做得到吗？
>
> 很明显这是不行的，会爆出以下错误：
>
> > 'A' is already defined in this compilation unit
>
> 于是这里就有了一个新概念，叫做编译单元（compilation unit），具体说：
>
> 1. 我们在写Java源代码时，总需要创建一个Java文件。通俗说一个Java文件就是一个编译单元
> 2. 一个编译单元中有且仅能有一个public修饰的类，public类的名字必须和编译单元的名字一致
> 3. **如果编译单元中已存在同名类，那么这时就不能通过导包去使用其它包下的同名类了！**
>
> 实际开发中，这种编译单元问题很罕见，了解即可。
>
> ---
>
> [-] 补充_编译单元的问题
>
> > 包是一组类的集合，一个包可以包含若干个类文件还可以包含若干个包
> >
> > <font color=red>**包的作用：**</font>
> >
> > 1. 在工程中用于组织Java文件，分类。
> >
> > 2. 类名的空间管理，同包禁止同名类，避免类名冲突。
> >
> >    **注：前两点和操作系统中的文件夹作用是一致的。**
> >
> > 3. 提供包一级的封装及访问权限控制。（面向对象后面的知识）
> >
> > <font color=red>**包的命名：**</font>
> >
> > 1. 全部小写英文单词，实际开发中多以反转公司域名为开头。
> > 2. 如果是名词，使用单数形式，不要用复数形式。
> >
> > <font color=red>**编译单元：**</font>
> >
> > 1. 一个Java源代码文件（Java文件）称为一个编译单元。
> > 2. 一个Java源代码文件由三部分组成：
> >    1. 所属包的声明，即package声明。
> >    2. 导入声明。即import声明。
> >    3. 主体声明。
> > 3. 一个编译单元只能有一个**public class**，该类的类名必须与文件名相同。但可以允许有多个**非public class**。经过编译后，该编译单元下的所有class都会生成<font color=red>**对应的、独立的**</font>字节码文件。
> >
> > <font color=red>**包的声明：**</font>
> >
> > 1. 语法和使用上面已经讲过，不赘述。
> > 2. 相同包声明的类（同包下的class），可以直接使用简单类名访问，无需其它操作。 
> >
> > <font color=red>**导入声明：**</font>
> >
> > 1. 语法和使用上面已经讲过，不赘述。
> > 2. 使用简单类名访问不同包下的class，必须添加导入声明。**特殊的，如果同一个编译单元下已存在同名结构，不能通过import导入该同名结构。**
> >
> > 主体声明：
> >
> > 1. 类、接口、注解等的结构声明。
> > 2. <span style=color:red;background:yellow>**上述声明中，只能有一个public修饰的结构。**</span>

###### The End
