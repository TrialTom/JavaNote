[TOC]

# 引例

> `>(green)`
>
> 创建一个教师类，有课程和年龄两个属性，行为是可以上课。
>
> 现在我们需要创建以下对象：
>
> 1. 18岁的Java老师对象
> 2. 28岁的C++老师对象
> 3. 30岁的Python老师对象
> 4. ...
>
> 按照之前我们的做法，需要先创建出对象，再进行成员变量的赋值，这样做如果只有一个两个对象还好，如果需要创建很多对象，就有点过于麻烦了，**对象的属性，能不能"出厂"的时候就设定好呢？**
>
> 这就需要，构造器来完成这个功能。

# 构造方法

## 概念

> `>(green)`
>
>  <span style=color:red;background:yellow>**构造方法（constructor），也叫构造器，在Java中使用new关键字，创建对象，必然调用构造方法。构造器的作用是用来给成员变量赋值的。**</span>
>
> 构造方法也是方法，但属于一种特殊的方法，具有以下特点：
>
> 1. 语法结构和一般方法不同，如下：
>
>    ``` java
>    [访问权限修饰符] 类名(形参列表){
>    	//方法体
>    }
>    ```
>
>    注：
>
>    1. 访问权限修饰符可以省略，这里我们默认它是public修饰的。
>    2. 类名的位置必须和当前类的类名完全一致。（类名是大驼峰的，这里也要大驼峰）
>    3. 形参列表可以为空，称之为无参构造方法，简称无参构造。当然也可以有参数，是为`有参构造`。
>
> 2. 没有返回值，也不需要写返回值类型。
>
> 3. new对象的时候，JVM自动去调用这个方法，构造方法无法通过普通方法的调用方式调用。

## 构造器的定义

> `>(red)`
>
> 我们以往创建对象，在类中没有定义任何构造器，但是现在我们知道，new对象就会调用构造器，那么这时调用的是哪个构造器呢？这个构造器又是从哪里来的呢？
>
> 很显然以往我们诸如`new Student()`之类的语句，调用的肯定是类的无参构造，我们没有写，所以：
>
>  <span style=color:red;background:yellow>**一个类中，如果没有显式的给出一个构造方法（包括有参无参），那么就会默认提供一个无参构造方法。**</span>
>
> 默认给出的无参构造器，形参为空，方法体为空，不能给任何成员变量赋值，其格式如下：
>
> ``` java
> public 类名(){}
> ```
>
> ---
>
> 无参构造不能完成成员变量赋，我们需要自己手写有参构造，<span style=color:red;background:yellow>**在构造器中也会隐含this传参**</span>，所以我们可以写出下列代码：
>
> ###### 有参构造
>
> ``` java
> public 类名(数据类型 变量名){
>   this.变量名 = 变量名;
> }
> ```
>
> ---
>
> 按照上述格式写出的构造器，诸如下列代码，我们称之为`标准格式构造器`：
>
> ###### 构造器的标准格式
>
> ``` java
> // Student类的无参构造
> public Student(){}
> // 给age属性赋值的有参构造
> public Student(int age){
>   this.age = age;
> }
> ```
>
> ----
>
> **一个类中，是允许同时定义多个构造方法的，这其实就是一种方法重载，多个构造器的形参必须不同。**

## 构造器的使用

> `>(green)`
>
> **虽然我们程序员不能直接调用构造器，但是可以通过new关键字、类名后面的小括号里写参数，来决定JVM调用哪个构造方法来给成员变量赋值。**这实际上是方法重载的应用。
>
> 构造器定义完毕后，我们就可以使用了，这时我们发现构造器就可以完成：类似于对象"出厂"就设置好属性值的作用，我们在new后面写什么参数，属性值就能够对应赋值。这是因为：
>
>  <span style=color:red;background:yellow>**在各式各样给成员变量赋值的方式中，构造器是最后执行的！！！**</span>

## 细节问题

> `>(green)`
>
> 注意事项：
>
> 1. 类中默认提供的无参构造方法，是在该类没有任何构造器的情况下才有的。但是如果类中有任一构造器（有参/无参），那么就没有默认无参存在了。
>
>    - 这里给一个小小的建议：建议在定义一个实体类时，顺手提供无参构造方法，这会是一个好习惯。
>
> 2. 构造方法中可以使用this关键字，去访问对象的成员（变量和方法），但一般没有意义。
>
> 3.  <span style=color:red;background:yellow>**在构造器中还可以使用this去调用其它构造器**</span>，语法如下：
>
>    ``` java
>    this(参数);
>    ```
>
>    注：如果使用this调用别的构造方法，那么这条语句必须在该构造方法的第一行，当然只能用一次。
>
> 4. 每new创建一个对象，都会调用一次构造方法，而类加载仅有一次。

## 总结成员变量赋值的方式

> `>(red)`
>
> 到目前为止，我们实际上已经知道了三种给成员变量赋值的方式：
>
> 1. 默认初始化，具有默认值。
> 2. 显式赋值，直接将值写在成员变量声明的后面。
> 3. 构造器
>
> 在研究成员变量赋值顺序时，要遵循`掐头去尾`的原则，三种赋值方式中：
>
> 1. 默认初始化永远的第一步，这是`头`。
> 2. JVM会在创建对象的最后一步去调用构造方法，无论我们后面还要学多少成员变量的赋值方式，构造器总是最后执行的。这是`尾`。
>    - 标准格式书写的构造器的赋值一定是正确性，“永远可以相信构造器”
>    - 当然，如果不是标准格式构造器，那赋值啥就不好说了。
> 3. 显式赋值，见到二位老大，只好屈居中间执行了。

# debug练习

> `>(green)`
>
> **对于下列程序代码，请指出创建Student对象，程序每一步的执行流程：**
>
> ``` java
> public class Demo{
>   public static void main(String[] args){
>     Student stu = new Student(18,"王冰冰");
>   }
> }
> class Student {
>     int age = 10;
>     String name = "张三";
>     double a = 100;
> 
>     public Student(int age) {
>         System.out.println("Student age");
>         this.age = age;
>     }
> 
>     public Student() {
>     }
> 
>     public Student(int age, String name) {
>         this(age);
>         System.out.println("Student age,name");
>         this.name = name;
>     }
> }
> ```
>
> 在这个案例中，我们发现Student双参构造器中，有使用this调用单参构造器，那么它们的执行顺序是：
>
> 1. 类加载不要忘记了。
> 2. 程序会先找到，Student的双参构造器，但是并不会执行，而是
> 3. 先跳转执行this构造器，但是this构造器中的代码，也不会立刻执行（因为构造器赋值一定最后执行），而是
> 4. 先从上到下执行成员变量的显示赋值，然后
> 5. 跳回执行this构造器代码
> 6. 最后执行双参构造器代码

###### The End
