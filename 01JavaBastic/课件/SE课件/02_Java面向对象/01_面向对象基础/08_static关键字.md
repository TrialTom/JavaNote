###### <sub><font color = orange>JAVASE基础教程</font></sub><br />——<br /><sup><font color=white>卷1</font></sup><font color=white>面向对象基础</font><br/><sup><sub><font color=cyan>节8</font></sub><font color=cyan>static关键字</font></sup><br/><br/>	``#最新版本|V2.0#(purple) ``<br/>**长风**<br/>*COPYRIGHT ⓒ 2021. 王道版权所有*

[TOC]

# 引入

> `>(red)`
>
> static关键字是我们从`Hello World`开始，就频繁使用的一个关键字
>
> **例如：**
>
> - 作为一个入口方法的main方法是使用static修饰的
> - 我们在刚刚学习方法时，要求方法的修饰符列表默认是public static中的static
>
> ....
>
> 但是，很显然我们虽然经常使用static关键字，但是却并不清楚它的涵义，它具体的作用等等
>
> 那么，接下来，我们就重点来学习一下static关键字

> `>(green)`
>
> 引例：
>
> > 练习：
> > 	创建一个学生类，用来描述我们班全体同学，要求
> > 		属性：姓名，性别，年龄，学号，学校信息
> > 		行为：吃饭，学习
>
> 注：建议性别使用String类型的gender，不推荐使用布尔类型的isMale或者isFemale。
>
> 创建多个Student对象，他们的属性取值可以不同，会发现什么问题呢？
>
> 显然，我们会发现以下问题：
>
> 1. 无论创建多少Student对象，由于该类描述的是我们班全体同学，他们的班级信息实际上是一样的
> 2. 创建多次对象，需要重复的给一个属性赋相同的值，这是很麻烦的，不方便的。
> 3. **学校信息这个属性实质上应该是被全体同学所共有的属性，而不是独属于某个对象的。**
>
> 所以，按照我们以往定义成员变量的方法来完成这个案例，是可以改进的。

# 改进引例

> `>(green)`
>
> 为了应对上述问题，我们需要改进我们的设计
>
> 考虑如何改进？
>
> 1. 可以把成员变量schoolName中直接显式赋值为“王道训练营”或者直接写死构造方法
>    - 这样确实可以实现功能，但是没有从根本上解决问题，问题3依然存在
>    - 学校信息这个属性在每一个对象当中都存在，有点浪费内存空间
>    - 最重要的，我们在设计类的时候其实已经知道这个属性，是全体对象都有，不应该属于某个对象。
>
> - **我们希望这个属性不是属于某一个对象的，而是一种类的特征，是属于类的，属于全体对象所共享的**
>
> 2. 上述改进不是我们最理想的改进方式，考虑以下改进：
>
>    - 在内存中找一块区域，让该类的每个对象都共用这片区域，把SchoolName属性放进去
>
>      **于是：**
>
>      - SchoolName从对象独有的成员变量变成全体对象所共享的一种变量
>      - 这样做既节省空间，减少了初始化成员变量的时间损耗
>
>    - **最重要的体现了该属性属于类，属于全体对象共享的特点**
>
> 实际上，属于全体对象所共享的变量在Java当中是存在的，它指的就是 <font color=red>**使用static关键字修饰的，Java当中的静态成员变量。**</font>
>

> `>(red)`
>
> **仅供了解**
>
> > 在JVM的内存设计中，确实存在一片被全体对象所共享的区域，在Java7版本及其之前，这片区域存在于方法区中
> > 在Java8后，JVM的内存设计迎来了巨大的变动，该区域被移到了堆当中
> > 注：Java8实际上对JVM的内存设计改动很大，JVM当中很多区域的实现都发生了翻天覆地的改变。但我们这个阶段没有必须了解其中的详情。感兴趣可以参考《深入理解Java虚拟机》一书。

# static关键字

> `>(green)`
>
> static关键字在修饰类中成员时，不仅可以修饰成员变量，还可以修饰方法。

## 定义语法

> `>(green)`
>
> static修饰成员变量被称之静态成员变量，简称**静态变量（**没有static修饰称之为普通成员变量或成员变量）
>
>  <span style=color:red;background:yellow>**静态成员变量的定义语法：**</span>
>
> 1. 需要定义在类的成员位置
>
> 2. 语法：
>
>    ```Java
>    [访问权限修饰符] static 数据类型 变量名;
>    ```
>
>  <span style=color:red;background:yellow>**静态成员方法的定义语法：**</span>
>
> 1. 需要定义在类的成员位置
>
> 2. 语法：
>
>    ```Java
>    [访问权限修饰符] static 返回值类型 方法名(形参列表){
>    	//方法体
>    }
>    ```
>
> **以上，我们把静态成员变量和静态成员方法，统称为类的静态成员。**
>
> 注：之前我们学method章节时，讲的方法默认public static修饰，它就是一个静态方法。

## 使用语法

> `>(red)`
>
> static修饰的静态成员的使用和普通成员是完全不同的：
>
> 1. 静态成员变量的使用具有以下特点:
>    1. 和普通成员变量一样,都具有默认值（默认值和普通成员变量是一样的）
>    2.  <span style=color:red;background:yellow>**静态成员变量属于全体对象所共享，换句话说是属于类的。所以不推荐使用对象名访问，而推荐使用类名点访问**</span>
>    3. 静态成员变量的访问/赋值/使用都不依赖于对象。
> 2. 静态成员方法的使用具有以下特点:
>    1. 无需创建对象就可以直接通过类名点直接调用。
>    2. 同一个类中的static方法互相调用可以省略类名，直接用方法名调用。（这就是我们之前方法的调用）

## 原理

> `>(green)`
>
> **引例**
>
> > 宠物公司新进了一批同样颜色的猫，创建一个类描述这批宠物
> > 注：创建该类时，给出一个静态成员变量和一个静态成员方法
>
> static修饰的成员，称之为静态成员，包括静态成员变量和静态成员方法。静态成员的访问并不依赖于创建对象，可以直接通过类名访问，其原因在于<font color=red>**随着类加载完毕，静态成员就存在，并且能够使用了！**</font>
>
> 1. 静态成员变量在类加载过程中完成默认初始化具有默认值，可以访问了。
> 2. 静态成员方法的二进制指令集合在类加载过程也准备完毕，可以调用了。
>
> 由于静态成员，先于对象在内存中出现，不依赖于对象而存在，所以：
>
> 1. 类加载只有一次，静态成员变量也只有一份且被类所有对象共享。
> 2. 静态方法被所有类对象共享，且无需创建对象就能调用
>
> 仍然可以创建对象去调用静态成员，但是规范的Java代码只建议通过类名直接访问
>
> - **静态成员变量：类名.变量名**
> - **静态成员方法：类名.方法名**
> - **对象名点调用的方式，可能会导致该成员属于对象的误解，所以不推荐使用**
>- 在很多书籍博客中，根据静态成员的随着类加载完毕而能使用的特点
>   - 所以也称呼静态成员为类成员，类属性，类变量，类方法等等
>     - 这种称呼了解即可，习惯上还是称呼它为静态成员
> 
>---
> 
>**关于static的来源**
> 
>> staic关键字最早来源于C语言，在C语言当中static用来定义那些在方法外面也可以使用的局部变量（全局静态变量）
> >C++借鉴和沿用了这个关键字，但是完全改变了它的涵义： static用来表示被对象所共享的成员
> > Java实际上又沿用了C++当中的static，所以staic的涵义早已和原本的涵义不同了。

# static与非static比较

> `>(green)`
>
> 当我们了解static成员的特点后，静态成员和非静态成员的区别就很明显
>
> 我们从以下四个角度比较（拿成员变量为例）
>
> 1. 成员的所属
> 2. 在内存中的位置
> 3. 在内存中出现的时间
> 4. 调用方式
>
> 其比较的结论如下：
>
> 1. 所属不同
>    - 静态成员变量属于类，所以也称为为类变量
>    - （普通）成员变量属于对象，所以也称为对象变量（实例变量）
> 2. 在内存中的位置不同
>    - 静态变量存储于方法区的静态区，被所有对象共享
>    - 成员变量存储于堆内存，每个对象独享自己的成员变量
> 3. 在内存中出现时间不同
>    - 静态变量随着类的加载而加载，比成员变量出现的要早
>    - 成员变量随着对象的创建而存在
> 4. 调用方式不同
>    - 静态变量可以通过类名调用，也可以通过对象调用（不推荐/不合理的方式）
>    - 成员变量只能通过对象名调用，必须创建对象
>
> **静态成员方法和普通成员方法的区别和上述类似，我们主要思考以下两个问题就可以了：**
>
> 1. 在静态方法中，能否访问非静态的成员，为什么？
> 2. 在普通成员方法中，能否访问静态成员，为什么？
>
> 答案：
>
> > 1，静态方法在类加载后，就可以使用了（或者换句话说，调用类的静态方法会触发类加载），所以这个时候对象是不一定存在的，既然对象不存在，就不可能存在this传参，显然就不可能在静态方法中访问非静态成员。
> >
> > 
> >
> > 2，普通成员方法中是隐含this传参的，也就是说方法体中连对象的普通成员都可以访问了，类加载一定已经进行了，这个时候访问静态成员显然是没有任何问题的。

# 使用场景

> `>(green)`
>
> > static关键字有什么具体的使用场景呢？
>
> 这里，我们显然需要根据static关键字的一些特点来明确它的使用场景
>
> 1. 静态成员变量：
>    - 属于全体对象所共享而不是独属于某个对象的成员变量，所以
>      - 当存在需要所有对象共享的变量时，应该使用static
>    - **不仅是全体对象共享的，而且是整个类全局独一份的（因为类加载只有一次）**
>      - 所以，如果希望某个变量在类的全局独一份，它应该是static修饰的变量
> 2. 静态成员方法：
>    - 静态方法的最主要特点就是调用简单，无需创建对象即可调用，所以
>      - 如果希望一个方法能够更方便快捷的去调用，可以把它声明为static修饰的静态成员方法
>    - 实际上根据静态成员方法调用简单的特点，当一个类中全部都是静态成员方法时
>      - 它的方法调用都可以使用类名点去完成，这就是Java当中的**“工具类”**
>      - 比如数组工具类Arrays、集合工具类Collections、数学工具类Math等等
>    - 当然，静态成员方法也可以用来给静态成员变量赋值，这类似于用成员方法给成员变量赋值
>      - 实际上成员方法也是可以给静态成员变量赋值的，但是这种赋值依赖于创建对象，是比较少用的方式

# 注意事项

> `>(red)`
>
> 1. 一个类中，静态方法无法直接调用非静态的方法和属性，也不能使用this，super关键字（super后面会讲）
>    - **经典错误：Non-static field/method xxx cannot be referenced from a static context**
>    - 原因：静态方法调用的时候，完全有可能没有对象，没有对象普通成员就无法访问
> 2. 普通成员方法当中，是可以访问静态成员的
>    - 显然，既然对象都存在了，类加载一定进行了，所以这种访问是完全可行的
>    - 建议采用这种访问形式的时候，使用类名.变量名的形式访问，以示区别，增加代码可读性
> 3. 只存在静态成员变量，不存在“静态局部变量”，包括静态方法中也没有“静态局部变量”
> 4. 静态成员变量不建议用构造方法赋值（因为这种赋值依赖于创建对象，不合适）
> 5. 普遍来说，访问静态成员，都建议加上类名去访问，提升代码可读性

# 补充——单例模式（需要补充在访问权限修饰符中）

> `>(green)`
>
> 单例模式（**Singleton**）是一种比较简单的设计模式，但比较常用。指的是在一个JVM里，某个类的对象仅存在一个实例。
>
> 我们学习过static关键字后，就可以使用这种设计模式了。
>
> 
>
> 

# 练习

> `>(red)`
>
> 牛刀小试，请说明程序的输出结果，并分析流程
>
> ###### static练习
>
> ``` java
> public class Demo {
>     static Cat cat = new Cat(); 
> 	Dog dog = new Dog();
> 	Dog dog2;
> 
>     public static void main(String[] args) {
>         System.out.println("hello world!");
>         Demo d = new Demo();
>     }
> 
>     public Demo() {
>         System.out.println("demo");
>     }
> }
> 
> class Cat {
>     static Dog dog = new Dog(); //static3 int a = 10;
> 
>     public Cat() {
>         System.out.println("cat");
>     }
> }
> 
> class Dog {
>     public Dog() {
>         System.out.println("dog");
>     }
> }
> ```
>
> 你能得出什么结论？

###### The End