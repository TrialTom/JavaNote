###### <sub><font color = orange>JAVASE基础教程</font></sub><br />——<br /><sup><font color=white>卷4</font></sup><font color=white>多态</font><br/><sup><sub><font color=cyan>节3</font></sub><font color=cyan>多态的优缺点和向下转型</font></sup><br/><br/>	``#最新版本|V2.0#(purple) ``<br/>**长风**<br/>*COPYRIGHT ⓒ 2021. 王道版权所有*

[TOC]

# 概述

> `>(green)`
>
> 多态是面向对象三大特征之一，它基于继承而实现，是面向对象思想的集大成者。接下来我们研究一下，它的优缺点。我们通过一个案例：
>
> > 科学家要收集动物的叫声去研究，先要收集猫，狗两种动物的叫声研究。随后又扩展到其它动物，最后又需要研究人类。

# 多态的优点

> `>(green)`
>
> 上述案例，我们可以先定义一个顶层父类Animal作为父类，然后定义具体动物类：猫和狗。
>
> 假如收集每种动物的叫声研究，都需要写一个方法，显然过于麻烦，程序扩展性也太差了。所以我们可以这么做：
>
> 1. 写一个方法来收集研究动物的叫声，方法的形参不写具体动物类，而写顶层祖先类：Animal。然后在方法体中，调用叫的方法即可。
> 2. 这样该方法在调用传参时，就可以Animal不同的子类对象了。这仍然是一个父类引用指向子类对象
>
> 这就是多态一个基本的使用案例，当传入方法不同的子类对象时，方法执行时就会根据不同的具体对象类型，来决定行为。
>
> ---
>
> 从这个案例，我们其实就可以大致总结多态的优点了：
>
> 1. 要实现多态必须要继承，而继承提高了代码复用率，提升了程序的可维护性。（继承保证）
> 2. 有了多态后，用父类引用指向不同子类对象，只需要调用同名方法，就能自动根据不同子类对象，得出不同的行为。这大幅度简化了代码，提升了程序的扩展性。（多态保证）
>
> > 这里讲一个形象的案例：
> >
> > 假如你做一个游戏，游戏中有很多角色，角色们都能释放技能，但技能各不相同。如果没有多态，那就必须逐一调用方法来释放不同的技能，但是有了多态只需要调用技能完事，程序会自动根据不同的角色对象，释放出不同的技能。
> >
> > ###### 模拟多态游戏
> >
> > ``` java
> > // 没有多态时：
> > 角色1引用.技能();
> > 角色2引用.技能();
> > 角色3引用.技能();
> > 角色4引用.技能();
> > // 有了多态后：
> > 角色父类引用.技能();
> > ```

# 多态的缺点

> `>(green)`
>
> 多态肯定是有缺点的，而且很明显。由于多态中，使用父类引用指向子类对象，父类引用限制了子类对象的功能，这意味着：
>
> - 子类独有的成员是无法使用父类引用访问的。
>
> **而一旦你必须在这时候访问子类独有成员的话，这就需要把父类类型引用，再转换回子类类型的引用，从继承的方向上，这是从上到下的，称之为"向下转型"。之前我们讲过，这属于强制类型转换。**
>
> 但是强转十分危险，稍有不慎就会导致程序异常，下面我们详细分析引用数据类型的强制类型转换。

# 引用数据类型的强制类型转换

> `>(red)`
>
> 父类的引用转换成子类的引用，在继承链中属于向下，属于"向下转型"。编译器默认不允许，需要显式地写代码完成类型转换。
>
> 语法：
>
> ``` java
> 子类类名 对象名 = （子类类名）父类引用;
> ```
>
> 当然上述语法不是乱写地，向下转型是有条件的。

## 发生的前提

> `>(green)`
>
> 发生的前提：**<font color=red> 必须将父类引用转换成它的子类引用，如果不是转换成它的子类引用，会编译报错。</font>**

## 成功的前提

> `>(red)`
>
> 成功的前提：  <span style=color:red;background:yellow>**父类引用指向的真实对象的类型，就是要强转成的子类类型的对象或者子类对象。**</span>
>
> 这个前提其实分为两个部分：
>
> 1. <font color=red>**父类引用指向的真实对象的类型，就是要强转成的子类类型的对象。**</font>
>
>    1. 比如我先做了一次自动转换，这时父类引用fs指向的实际对象就是Son子类对象
>
>       ``` java
>       Father fs = new Son();
>       ```
>
>    2. 那么做强转，将fs引用，强转回Son类的引用，是完全可以的。
>
>       ``` java
>       Son s = (Son)fs;
>       ```
>
>    3. 这种强转的形式还是比较好理解的，本质上**其实是一次"物归原主"，Son对象本身就该是Son引用指向的，强转回去就不会出错。**
>
>    4. **假如Father还有一个子类Son2，那么将fs强转成Son2引用，虽然编译不会报错，但运行一定会出错。**
>
> 2. <font color=red>**父类引用指向的真实对象的类型，就是要强转成的子类类型的子类对象。**</font>
>
>    1. 先假设有一个三层的继承体系：
>
>       ###### 强转成功前提代码块1
>
>       ``` java
>       class Father{}
>       class Son extends Father{}
>       class Grandson extends Son{}
>       ```
>
>    2. 然后做一次自动类型转换，这时父类引用其实指向的是"孙子类"对象。
>
>       ``` java
>       Father fs = new Grandson();
>       ```
>
>    3. 那么做强转就有了两个选项，其中将fs强转成Son引用，就符合<font color=red>**父类引用指向的真实对象的类型，就是要强转成的子类类型的子类对象。**</font>
>
>       ###### 强转成功前提代码块2
>
>       ``` java
>       Son fs1 = (Son) fs;
>       Grandson fs2 = (Grandson) fs;
>       ```
>
>    4. <span style=color:red;background:yellow>**这种场景实际开发中，不多见，但也要知道。**</span>
>
> ---
>
> 如果看完上面的，你还似懂非懂，那就看下图再去理解一下：
>
> <img src="https://hixiaodong123.oss-cn-hangzhou.aliyuncs.com/typora/202201101203334.png?align=center" alt="向下转型成功前提" style="zoom: 25%;" />
>
>  <font color=red>**说明：**</font>
>
> > **Grandson对象有三个引用都可以指向它，Father、Son、Grandson**
> >
> >  <span style=color:red;background:yellow>**那么假如Father引用指向它时，父类引用Father就可以强转为Son或者Grandson引用。**</span>
> >
> > 
> >
> > **Son对象有两个引用可以指向它，Son、Father**
> >
> >  <span style=color:red;background:yellow>**那么假如Father引用指向它时，父类引用Father就可以强转为Son**</span>
> >
> > 
> >
> > **所以强转能够成功的前提条件是：引用所指向的真实对象，必须是强转后的引用能够指向的对象。所以可以是强转后的引用的类型的对象或者子类对象**

## instanceof关键字

> `>(red)`
>
> `向下转型`是一种强转，它成功的条件相对比较苛刻。在操作之前，要先慎重考虑。
>
> 强转失败会导致程序抛出异常：`ClassCastException`，导致程序终止执行。正是由于强转的条件苛刻，而且失败后果很严重，所以Java当中提供了检测手段，来保障强转的安全性。需要使用关键字： <span style=color:red;background:yellow>**instanceof**</span>
>
> 语法：
>
> ``` java
> 引用名 instanceof 类名
> ```
>
> 上述语法返回一个boolean类型值：
>
> 1.  <span style=color:red;background:yellow>**true表示该引用指向的对象，是后面类名的一个对象或者子类对象。**</span>
> 2. 反之，false则表示不是。
> 3.  <span style=color:red;background:yellow>**当引用指向null时，使用该语法，结果会直接返回false。**</span>
>
> 显然，无论引用指向的对象，是后面类名的对象还是子类对象，都符合强转成功的条件。普遍情况下，可以直接将上述语法直接写在if判断中，判断结果是true后，就可以放心大胆做强转处理了。

## 总结

> `>(green)`
>
> 引用数据类型要成功"向下转型"，完成强转条件是很苛刻的，实际开发中，先慎重考虑是否真的需要强转。然后在做强转之前，也需要使用`instanceof`关键字判断，保障安全性。麻痹大意，导致抛出`ClassCastException`异常，就会很难受了。

###### The End
