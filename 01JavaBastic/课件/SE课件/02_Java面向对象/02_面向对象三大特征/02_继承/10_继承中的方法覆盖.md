###### <sub><font color = orange>JAVASE基础教程</font></sub><br />——<br /><sup><font color=white>卷3</font></sup><font color=white>继承</font><br/><sup><sub><font color=cyan>节10</font></sub><font color=cyan>继承中的方法覆盖</font></sup><br/><br/>	``#最新版本|V1.0#(purple) ``<br/>**长风**<br/>*COPYRIGHT ⓒ 2021. 王道版权所有*

[TOC]

# 概述

> `>(green)`
>
> 在上一节一样，父子类中的成员方法也是可以同名的。那么我们直接创建子类对象，使用子类引用接收。调用同名方法，会发现访问的结果是子类中方法的行为，那么父类中的那个同名成员方法去哪了呢？还能够访问吗？首先它肯定是存在的，方法不过是方法区的二进制指令合集罢了，类加载时期，装载进方法区，不会物理消失。但 <font color=red>**"对象名点"访问成员方法**</font> 这个语法还是和访问成员变量是有很大区别的， 我们可以写一个public方法，然后在方法中访问同名成员方法，最后测试调用这个public方法，如下：
>
> ###### 测试方法覆盖
>
> ``` java
> public void test() {
>     System.out.println("father test");
> }
> public void invokeFatherTest() {
>     this.test();
> }
> ```
>
> 注：test是那个同名的成员方法
>
> 我们会发现，方法调用的结果仍然体现子类中的方法行为，这就有点意思了。接下来我们就来探讨一下这种 <font color=red>**对象名点访问成员方法**</font> 的机制。

# 对象名.成员方法的访问机制

> `>(green)`
>
> 和前面访问成员变量一样，在研究 <font color=red>**对象名点访问成员方法**</font> 机制时，我们主要探究两个方向：
>
> 1. 访问范围，究竟能够访问到哪些成员方法？根据什么来决定？
> 2. 访问结果，如果是父子类同名成员方法，那么结果是什么？根据什么来决定？
>
> ---
>
> 首先是 <font color=red>**对象名点访问成员方法**</font> ，对象的由来，可以有三种方式：
>
> 1. 创建父类对象,用父类引用接收，用对象名点访问。
> 2. 创建子类对象,用子类引用接收，用对象名点访问。
> 3. 创建子类对象,用父类引用接收，用对象名点访问。

## 访问范围机制

> `>(red)`
>
> 实际上不管是，属性的访问还是成员方法的访问，范围都是一个编译上的概念，所以结果即便不测试也是和，上节中属性的访问范围是一样的。当然，测试后结果仍然是：对象名点成员方法，它的访问范围是由 <font color=red>**引用的数据类型**</font> 来决定的。
>
> 1. 如果引用是父类类型，那么它的访问范围只有父类（和父类的父类）。
> 2. 如果引用是子类类型，那么它的访问范围是子类 + 父类（父类如果还有父类也算上）

## 访问结果机制

> `>(red)`
>
> 对象名点成员方法，访问的结果就不再是由 <font color=red>**引用的数据类型**</font> 来决定了，而是根据 <span style=color:red;background:yellow>**对象的实际类型**</span> 来决定。
>
> 1. 如果对象是一个子类类型，那么即便引用是父类，方法调用也要体现出子类的行为。
> 2. 反之如果对象是一个父类类型，方法调用的结果就是父类行为。

## 总结

> `>(green)`
>
> 综合对象名点访问成员方法的范围和结果，发现：
>
> 1. 访问范围仍然是要靠 <font color=red>**引用的数据类型**</font> 来决定。
> 2.  <span style=color:red;background:yellow>**但是方法的调用结果，就需要考虑对象的具体类型，是何种对象，就体现出它的行为。**</span>
>
> 注意事项：
>
> 1. 父子类中一旦存在父子类同名的成员方法，那么**只要创建子类对象**，在任何位置都无法再`直接`访问到父类成员方法了，这就是继承中的`方法的覆盖`。
> 2. 方法的调用之所以体现为`覆盖`，这是因为方法的调用结果是根据对象的实际类型决定的，和引用没有任何关系。
> 3. 当然，方法的覆盖不是物理意义上的覆盖，只是方法的访问机制决定的。这个父类中的同名方法，仍然可以使用**super**关键字去访问到，当然前提是有访问权限。
>
> 结合我们前面封装的思想，实际开发中，大多数的成员变量都是私有化的，这意味着使用 <font color=red>**对象名点访问成员变量**</font> 的机会是很罕见的，多数情况下我们都是在调用方法完成各种功能。<span style=color:red;background:yellow>**方法的覆盖是非常重要的知识点，如果说继承是面向对象的核心，那么继承应该就属于方法的覆盖。接下来讲解方法覆盖的语法。**</span>

# 方法的覆盖/重写

> `>(red)`
>
> 方法的覆盖，也叫方法的重写（override），指的是在子类中，能够改写父类成员方法的内容。从形式上表现出来，就是父子类中能够拥有同名的成员方法。
>
> 在讲解具体的方法重写的语法和使用之前，我们要先讲解一个注解：`@Override`，就和它的名字一样，这个注解写在子类的方法头上，用于检测子类中的某个方法，是否是父类方法的重写。例如下列代码：
>
> ###### @Override注解
>
> ``` java
> // 父类方法
> public void test(){
>   System.out.println("father");
> }
> // 子类方法
> @Override
> public void test(){
>   System.out.println("son");
> }
> ```
>
> 在实际开发中，我们要求大家，在任何时候，**只要是在做方法的重写，就一定要加上注解**`@Override`，好处是：
>
> 1. 能够检测语法，如果因为没加注解，导致将本不是方法重写的方法，误以为是方法重写，将会带来错误。
> 2. 提升代码可读性，加了该注解的方法一定是重写自父类的方法。
>
> ---

## 语法

> `>(green)`
>
> 方法的重写的语法要求，对于下列一个成员方法：
>
> ###### 成员方法的语法
>
> ``` java
> // 成员方法的语法
> [访问权限修饰符] 返回值类型 方法名(形参列表){
>     //方法体
> }
> ```
>
> 1. 子类中重写的方法，访问权限等级，必须至少保持一致，可以更为`宽松`，但一定不能更`严格`。
>
> 2.  <span style=color:red;background:yellow>**子类中重写的方法，返回值类型必须和原先父类方法的返回值类型，保持`兼容`。**</span>
>
>    注：何为兼容呢？这里留给大家思考~
>
> 3. **子类中重写的方法，方法名必须严格保持一致，不能做任何修改。**
>
> 4. **子类中重写的方法，形参列表必须保持严格一致，不能做任何修改。**
>
> 5. 方法体的代码，无所谓，可以保持一致，也可以修改。
>
> ---
>
> 最后，在这里做一个扩展。回想一下我们之前学过的`方法的重载`，它和`方法的重写`语法上有什么区别呢？
>
> 这里用一个表格，来描述：
>
> ###### 方法重写 VS 方法重载
>
> |                | 方法的重载（overload） |               方法的重写（override）               |
> | :------------: | :--------------------: | :------------------------------------------------: |
> |  发生的类不同  |      必须在同类中      |      必须发生在父子类之间，肯定不是同一个类中      |
> |     方法名     |      **必须相同**      |                    **必须相同**                    |
> |    参数列表    |      **必须不同**      |                    **必须相同**                    |
> | 访问权限修饰符 |   **不影响，无所谓**   | 子类方法的访问权限，不允许更严格（可以一致或宽松） |
> |   返回值类型   |   **不影响，无所谓**   |      子类方法返回值类型保持兼容，不用完全一致      |
> |      异常      |   **不影响，无所谓**   |          **重写的方法不能抛出更多的异常**          |

## 注意事项                                                                                                                                                                                                                                                                                                                                                                                                                                                               

> `>(red)`
>
> 1. 父类中私有方法不能被重写（因为没有权限访问，更不谈重写）
> 2. 静态方法在使用现象上，很像是被重写了，但实际上静态方法不能被重写，而是直接是一个新的静态成员。（使用`@Override`注解标记会报错）
> 3. 构造器不能继承，更不能被重写。
> 4. 实践开发中，重写一个方法，不要傻乎乎的真的去复制粘贴父类代码，这样做不仅浪费时间，也经常容易忘记添加注解`@Override`，推荐以下几种方式：
>    1. 直接在子类中，手写出父类方法的名字。看到出现父类方法提示，直接回车即可重写。
>    2. 使用快捷键`Alt + Insert`，在选项`Override Methods`中，选择重写子类的方法。

###### The End
