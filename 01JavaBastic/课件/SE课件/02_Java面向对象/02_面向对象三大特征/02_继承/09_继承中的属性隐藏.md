###### <sub><font color = orange>JAVASE基础教程</font></sub><br />——<br /><sup><font color=white>卷3</font></sup><font color=white>继承</font><br/><sup><sub><font color=cyan>节9</font></sub><font color=cyan>继承中的属性隐藏</font></sup><br/><br/>	``#最新版本|V1.0#(purple) ``<br/>**长风**<br/>*COPYRIGHT ⓒ 2021. 王道版权所有*

[TOC]

# 概述

> `>(green)`
>
> 在上面章节中，我们已经知道，父子类的成员是允许同名的。那么如果父子类属性同名了，那么不使用super区分，直接访问的效果是什么样的呢？
>
> 现在我们直接创建子类对象，使用子类引用接收。会发现访问的结果是子类中属性的取值，那么父类中的那个成员变量去哪了呢？首先它肯定是存在的，这一点随便写一个父类成员变量的Getter方法就可以验证了。这说明使用 <font color=red>**"对象名点"访问成员变量**</font> 这个语法，可能存在一些特殊的机制，接下来我们就来探讨这种机制。

# 对象名.成员变量的访问机制

> `>(green)`
>
> 在研究 <font color=red>**对象名点访问成员变量**</font> 机制时，我们主要探究两个方向：
>
> 1. 访问范围，究竟能够访问到哪些成员变量？根据什么来决定？
> 2. 访问结果，如果是父子类同名成员变量，那么结果是什么？根据什么来决定？
>
> ---
>
> 首先是 <font color=red>**对象名点访问成员变量**</font> ，对象的由来，可以有三种方式：
>
> 1. 创建父类对象,用父类引用接收，用对象名点访问。
> 2. 创建子类对象,用子类引用接收，用对象名点访问。
> 3. 创建子类对象,用父类引用接收，用对象名点访问。

# 属性隐藏

## 访问范围机制

> `>(red)`
>
> 经过上面的测试，我们可以知道对象名点成员变量，它的访问范围是由 <font color=red>**引用的数据类型**</font> 来决定的。
>
> 1. 如果引用是父类类型，那么它的访问范围只有父类（和父类的父类）。
> 2. 如果引用是子类类型，那么它的访问范围是子类 + 父类（父类如果还有父类也算上）。
>
> ---
>
> 在Java当中，对象名点访问成员变量的范围是编译器决定的，是一个编译上的概念。编译在检索一个引用是否能够访问到某个成员变量时，存在以下检索机制：
>
> 1. 首先编译器会从**引用的数据类型**的那个类中，去查找该成员变量。如果找到了，就直接认为它可以访问。（有权限才行）
> 2. 如果没有找到，那么就去父类中找。直到找到Object类，如果Object类当中都没有该成员变量，那就会编译报错。
>
> 上述规则，实际上可以总结为：
>
> 在Java中，访问范围是可以往上查找父类的，但不能往下找子类。 <span style=color:red;background:yellow>**子类知道自己的"爸爸"是谁，但"爸爸"并不知道它有这个"儿子"，甚至都不知道自己有几个"儿子"，或者有没有"儿子"。**</span>

## 访问结果机制

> `>(green)`
>
> 对象名点成员变量，访问的结果也是由 <font color=red>**引用的数据类型**</font> 来决定的。
>
> 1. 如果引用是父类类型，那么它的访问结果一定也是父类中的结果。
> 2. 如果引用是子类类型，那么它的访问结果一定也是子类中的结果。

## 总结

> `>(green)`
>
> 综合对象名点访问成员变量的范围和结果，发现：<span style=color:red;background:yellow>**都是根据引用的数据类型来决定的，无需考虑是何种对象。**</span>
>
> 注意事项：
>
> 1. 父子类中的同名成员变量它们各自有存储的区域，父类的同名成员变量被子类同名成员变量隐藏了，称之为"属性的隐藏"。
>
>    但我们仍然可以通过父类中的Getter方法，或者通过super去访问到父类中同名成员变量，当然它们都受访问权限限制。
>
> 2. 静态成员变量在父子类中也存在同名的情况，但是它们不是覆盖也不是隐藏，而是互相独立的两个静态成员变量。
>
>    对于下列代码：
>
>    ``` java
>    class Person {
>        static String nationality;
>    }
>    
>    class Student extends Person {
>        static String nationality;
>    }
>    ```
>
>    Person类和Student类的静态成员变量`国籍`分别属于两个类本身，没有所谓继承关系。
>
>    而如果是下列代码：
>
>    ``` java
>    class Person {
>        static String nationality;
>    }
>    
>    class Student extends Person {
>    }
>    ```
>
>    Person类和Student类都可以使用Person类的静态成员变量`国籍`，是共用的关系。

###### The End
