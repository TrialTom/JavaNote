###### <sub><font color = orange>JAVASE基础教程</font></sub><br />——<br /><sup><font color=white>卷3</font></sup><font color=white>继承</font><br/><sup><sub><font color=cyan>节11</font></sub><font color=cyan>final关键字</font></sup><br/><br/>	``#最新版本|V1.0#(purple) ``<br/>**长风**<br/>*COPYRIGHT ⓒ 2021. 王道版权所有*

[TOC]

# 概述

> `>(green)`
>
> final有最终的、最后的意思。它是一个修饰符，可以用来修饰：
>
> 1. class类
> 2. 方法
> 3. 变量（包括成员变量、静态成员变量和局部变量）
>
> 它修饰不同结构时涵义是不同的，下面详细了解一下。

# final修饰类

> `>(green)`
>
> final修饰类时，表示最后的类，最终的类。即表示这个类不能被继承。
>
> 语法：
>
> ``` java
> [访问权限修饰符] final class 类名{
>     //类体
> }
> ```
>
> 说明：
>
> 1. final修饰class后，该类就无法被继承了。但是该类的其他使用不会受到影响，比如创建对象，调用方法等等。其它方面，它仍然还是一个普通的类。
>
> 2. 思考：什么样的类需要设置成final？
>
>    不需要，不想要被子类继承的类，才需要设置为final修饰。当你认为当一个类的设计已经足够完善，功能足够强大了，不需要再让子类去扩展它了。这时出于安全的考虑，就可以将一个类设置为final。这样类中成员，既不会被继承，更不会被修改。
>
> 3. 正常情况下，我们很少会主动把一个类设置成final，因为没有太多的必要性。实际开发中，也要慎重将一个类设置final。
>
> 4.  常见的final修饰的类，都在JDK的源码当中。比如四类八种基本数据类型的包装类、Void、String、System、Scanner等等。

# final修饰方法

> `>(green)`
>
> final修饰方法表示最后的方法，最终的方法，表示该方法无法被重写 <span style=color:red;background:yellow>**（但是仍然可以被继承）**</span>。
>
> 语法：
>
> ``` java
> [访问权限修饰符] final 返回值类型 方法名(形参列表){
>     //方法体
> }
> ```
>
> 说明：
>
> 1. **final修饰成员方法，表示该方法无法被重写，但是仍然是可以继承的。**
> 2. 什么样的成员方法应该设置为final呢？
>    1. 方法的设计已经比较完善，不需要子类进行修改了，子类只需要乖乖继承，使用父类的实现即可。比如一旦修改就会导致问题、bug等时，就可以设置为final修饰。
>    2. 即便是父类的方法不是很完善，但只要是希望子类不要改写方法都可以这么做。（要么你就用，不爽你就自己实现一个）
> 3. 日常开发，程序员还是比较少见有需要把方法设置成final修饰的。同样比较多见于JDK源码中，比较常见的有：像Object类中的getClass()方法还有其中和线程相关的方法。
>
> ---
>
> 注意：
>
> 并不是随便拿一个方法都能用final修饰的，比如：
>
> 1. private方法，本来就无法重写，不需要多此一举。（可以修饰，但是会报警告）
> 2. static方法，本来就无法重写，不需要多此一举。（可以修饰，但是会报警告）
> 3. 构造方法，不能被继承，更不能重写，加final修饰会编译报错。

# final修饰变量

> `>(green)`
>
> final修饰变量，表示最后的变量，最终的变量，即表示常量。（表示在整个程序期间，值不会再变了）
>
> **final修饰变量时可以修饰局部变量，成员变量，静态成员变量。**总体上来说，要注意下述三个细节：
>
> 1. 自定义常量，不会更改变量的存储位置，生命周期，使用方式等等。唯一改变就是值从能改变，变成不能改变。
>
>    1. 成员变量 ----> 成员常量
>    2. 局部变量 ----> 局部常量
>
> 2. final修饰变量时，可以修饰基本数据类型变量，也可以修饰引用数据类型。
>
>    1. 修饰基本数据类型时，很容易理解，值不变。
>    2.  <font color=red>**修饰引用数据类型时，修饰的是引用而不是对象，表示引用中存储的地址成为一个常量，不可更改。**</font>这意味着引用指向的对象不可更改了，不能再指向一个新的对象了。<font color=red>**但对象中成员变量的取值仍是可以修改的。（对象的状态仍可变）**</font>
>
> 3. 之前，我们在很早的时候提到过，常量的分类：
>
>    1. 字面值常量：1，2.0，3，"hello"等
>    2. 自定义常量： <span style=color:red;background:yellow>**被final修饰的变量，就是自定义常量。**</span>
>
>    自定义常量的命名：单词全部大写，两个单词之间用"_"隔开。
>
>    自定义常量的命名规范，不要求严格遵守，因为即便是JDK中的源码也没有百分百遵守。从实际开发角度出发， <font color=red>**建议成员静态常量，即final修饰静态成员变量时，遵守命名规范，其它常量随意。**</font>
>
> 接下来，分情况讨论final修饰变量。

## final修饰局部变量

> `>(green)`
>
> 我们以方法中的局部变量为例子，方法中的局部位置有两个：
>
> 1. 方法体：
>    - 方法体中用final修饰局部变量，表示该变量一旦声明并初始化赋值，就不可再修改它的取值了。
>    - 语法上，直接使用final修饰即可。
> 2. 方法的形参列表中：
>    - **形参用final修饰后，不是表示该方法只能传入常量，而是实参一旦传入后就无法在方法体中修改了。**
>    - 语法上，直接使用final修饰即可。
>
> 注：final修饰局部变量后，会变成一个`局部常量`。仍然在方法栈帧中创建存储，随着方法`同生共死`，除了值不能变，没有其它区别。

## final修饰成员变量

> `>(green)`
>
>  final修饰成员变量表示该成员变量变成了一个常量，它在内存中的位置，生命周期，使用方式等都不会改变。
>
> 语法：
>
> ``` java
> [访问权限修饰符] final 数据类型 变量名;
> ```
>
> 如果直接在类中成员位置，写上述语法定义成员"常量"，肯定会报错。这是因为默认值不能当成final修饰成员变量的取值，必须 <span style=color:red;background:yellow>**（在创建对象过程中）**</span>显式明确的给出一个值，而且这个值一旦给出就不可更改了。也就是说， <span style=color:red;background:yellow>**成员常量的赋值，有且必须有一次。**</span>目前我们给成员变量的赋值方式还有（除了默认初始化）：
>
> 1. 显式赋值
> 2. 构造代码块赋值
> 3. 构造器赋值
>
> **以上三种方式，选择其一即可，而且也必须，也只能选择其一。其它对象创建完毕后的赋值方式都不行。**
>
> 注：如果依赖构造器赋值，必须保证类的每个构造器都能完成成员变量的赋值，否则会编译报错。（想一想为什么？）
>
> 下列代码就是不正确的，因为如果无参创建对象，age这个常量就没值。
>
> ###### 构造器赋值final成员常量
>
> ``` java
> final int age;
> public Student(){}
> public Student(int age){
>   this.age = age;
> }
> ```
>
> ---
>
> 最后思考： **成员"常量"是不是真正意义上的常量?**
>  不是，因为成员"常量"属于对象，每个对象可能都有自身的常量取值，完全可能不同，而真正意义上的常量，像PI这种，是肯定不会因为创建对象而产生不同的。所以实际开发中，成员常量是很少见的。
>  <font color=red>**假如我们希望得到一个真正意义上的常量，在类的整个全局它的值都独一份，它应该是final修饰的静态成员变量。**</font>

## final修饰静态成员变量（常用）

> `>(red)`
>
> final修饰静态成员变量表示一个静态的"常量"，在<span style=color:red;background:yellow>**类的全局仅有一份**</span>，所以final修饰静态成员变量，也称之为<font color=red>**"全局常量"**</font>。它是一个真正意义上的常量，不会因为创建对象而更改，实际开发中的常量多使用它。
>
> 语法：
>
> ``` java
> [访问权限修饰符] static final 数据类型 变量名;
> ```
>
> 和final修饰成员变量一样，全局常量的取值也不能依赖于默认值，必须 <span style=color:red;background:yellow>**（在类加载过程中）**</span>明确一个值。这样静态成员变量的赋值方式还有（除去默认初始化）：
>
> 1. 显式赋值
> 2. 静态代码块
>
> **以上两种赋值方式，必须且只能选择其一。其他的赋值方式，比如在创建对象过程中的赋值方式，都是不可以的**
>
> ---
>
> 注意：
>
> 1.  <span style=color:red;background:yellow>**final static**</span> 还是 <span style=color:red;background:yellow>**static final**</span> 实测下来，都是可以的，根据个人习惯使用即可。
> 2. final修饰静态成员变量是一个全局常量，不会害怕外界访问和修改。所以在很多时候，它的访问权限修饰符都是public的。
> 3. 如果使用静态代码测试类加载，那么访问类的全局常量，有些场景是不会触发类加载的。（感兴趣自己测试一下，作为锻炼动手能力的小demo）

## final修饰引用数据类型

> `>(green)`
>
> 前面已经提到过了，final修饰引用数据类型的变量，表示引用不能指向新的对象， 但是对象的状态是可以被改变的。
>
> 语法：
>
> ``` java
> final 类名 对象名 = new 类名(参数);
> ```
>
> 注：final只能修饰引用，所以它不能去修饰匿名对象。下面代码是不允许的：
>
> ``` java
> final new Student();
> ```

# 小练习

> `>(red)`
>
> 牛刀小试：
>
> 1. 读程序，回答注释问题。
>
>    ###### 练习1
>
>    ``` java
>    public static void main(String[] args) {
>        byte num1 = 0;
>        byte num2 = 0;
>        final byte num3 = 10;
>        final byte num4 = 20;
>        byte result;
>      	// 下列代码哪行能通过编译，哪行不能？
>        result = num1 + num2;
>        result = num3 + num4;
>        result = num1 + num3;
>    }
>    ```
>
> 2. 注释中的两行代码，哪一行能正常运行？
>
>    ###### 练习2
>
>    ``` java
>    public int test(final int a){
>        //return a++;
>        //return a+1;
>    }
>    ```
>
> 3. 注释中的两行代码，哪一行能正常运行？
>
>    ###### 练习3
>
>    ``` java
>    public class Demo {
>        public static void main(String[] args) {
>           final Student s = new Student();
>           // s = new Student();
>           // s.age = 18;
>        }
>    }
>    class Student{
>        int age;
>        public Student() {
>        }
>    }
>    ```

###### The End
