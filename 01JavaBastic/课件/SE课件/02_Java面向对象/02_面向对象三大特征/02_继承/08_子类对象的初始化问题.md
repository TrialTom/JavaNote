###### <sub><font color = orange>JAVASE基础教程</font></sub><br />——<br /><sup><font color=white>卷3</font></sup><font color=white>继承</font><br/><sup><sub><font color=cyan>节8</font></sub><font color=cyan>子类对象初始化问题</font></sup><br/><br/>	``#最新版本|V2.0#(purple) ``<br/>**长风**<br/>*COPYRIGHT ⓒ 2021. 王道版权所有*

[TOC]

# 何为子类对象的初始化问题？

> `>(green)`
>
> > 何为子类对象初始化问题?
>
> **我们先复习一下我们认识引用数据类型的过程：**
>
> 1. 首先我们从数组对象的初始化开始，我们知道引用数据类型变量分为两个部分，在堆上创建对象，在栈中创建引用，引用通过存储地址指向堆上的对象。对象是引用数据类型的实质，但是我们不能直接访问对象，而是通过栈上的引用间接访问堆上的对象。
>
> 2. 然后我们学习了对象与类的概念，引入了类加载的概念。并且使用数据类型的定义统一了引用数据类型和基本数据类型：
>
>    数据类型：一组数据 + 基于数据的一组合法操作
>
>    引用数据类型：成员变量的合集 + 成员方法的合集
>
>    也就是说，引用数据类型（类）是特殊的数据类型，是自定义的数据类型。这种自定义的数据类型JVM不认识它，需要一个了解认识它的过程，称之为类加载。
>
>    JVM通过类加载了解一个类型，从而能够完成创建对象，或者其它的一些操作。
>
> 3. 现在我们学习了继承的概念，在继承中，子类会继承父类的成员，<font color=red>**使用子类对象可以直接访问父类中继承过来的成员**</font>。那么问题就来了：
>
>    1. 父类的成员从何而来？凭空出现？
>    2. 父类的成员变量也需要赋值，那么赋值顺序是怎么样的？结果是怎么样的？为什么会体现出这种特点？
>    3. 等等
>    
>    以上问题就是子类对象的初始化问题，即研究子类对象创建时，父类的成员从何而来，父类成员变量的赋值等相关的问题。
>
> ---
>
> 我们通过一个引例，练习来讲解这个问题：
>
> > 1. 创建一个Person类，有name属性和eat方法
> > 2. 创建一个Star类，有stageName属性和sing方法
> > 3. Star类要继承Person类
> > 4. 创建Star类对象，画出这个过程的内存图，描述子类对象初始化的过程。

# 子类对象的初始化流程

> `>(green)`
>
> 在创建子类Star对象的过程中，首先要考虑的就是类加载。Star这个类肯定是需要进行类加载的，但Star还有父类Person。子类对象能够直接访问父类成员，显然父类成员究竟有哪些，都是些啥，这些信息JVM是需要知道的（不如如何创建？）。所有：
>
> <span style=color:red;background:yellow>**子类的类加载会触发父类的类加载，并且类加载的顺序是"先父后子"的。**</span>
>
> 这里，我们可以总结类加载的时机：
>
> 1. 启动main方法
> 2. 创建对象
> 3. 访问类的静态成员
> 4. 子类类加载会触发父类类加载（不管子类是何种方式触发类加载）
>
> ---
>
> 类加载结束后，开始创建对象。首先要明确的就是，只会创建子类对象本身，而不会创建父类对象，堆上只有一个子类对象，没有任何父类对象。
>
> 接下来<font color=red>**子类对象中会专门开辟一片独立的区域，用来存储父类的成员变量**</font>，而子类自身的成员仍会存储在自身对象当中。这样子类对象就被划分为了两个区域。
>
> 之前，我们讲过，在构造器或成员方法中隐含this传参指向当前对象，那么这里子类对象中父类那片独立区域就使用super引用指向。并且这片专属于父类成员的区域，由于可以近似看成一个父类对象， <span style=color:red;background:yellow>**所以也可以认为super指向当前对象的父类对象。**</span>由于这个特点，super可以在**子类构造器或成员方法**中，用于**调用父类构造器或者访问父类成员**。
>
> ---
>
> 接下来需要父子类成员变量的赋值：
>
> 1. 它们的默认初始化具有默认值的过程，不需要去考虑它们的先后顺序（实际上在对象的成员变量的其他赋值方式开始赋值时，它们已经具有了默认值)
> 2. 除了默认初始化外的其它赋值方式，都是"先父后子"的。（这一点很自然，有"爸爸"才能有"儿子"啊）
>
> 父子类成员变量的赋值顺序的"先父后子"，是怎么保证的呢？为什么能够体现出这种特点呢？**接下来，我们详细分析一下子类对象中，父子类成员变量的赋值顺序。**

# 隐式子类对象初始化

> `>(red)`
>
> 父子类成员变量的赋值顺序的"先父后子"，是通过父子类构造器调用的"先父后子"保证的。但是注意 <font color=red>**在子类对象创建的过程中，父类的构造方法会被调用，但是不会创建父类的对象。**</font>
>
> >  <font color=red>**如果父类的构造器先于子类构造器执行：**</font>
>
> **那么父类所有的成员变量的赋值方式都是先于子类成员变量的任何赋值方式（默认初始化除外）**，于是自然父类成员变量的赋值顺序都会先于子类的。
>
> ---
>
> 在创建上述Star类对象时，我们没有在代码的任何位置，表示将要去调用父类构造器，但实际上父类构造器仍被调用了。这是为什么呢？
>
> 在Java的任何构造器当中，如果第一行没有明确的去调用别的构造器（通过this或super关键字）
>
> 那么第一行一定隐含了一条语句：
>
> ``` java
> super();
> ```
>
> 该行语句表示去调用父类的无参构造方法。于是，在子类对象初始化时，就会保证先去执行父类构造方法。这样就能够保证，父类成员变量的赋值一定先于子类。由于，程序员没有写任何代码，这种子类对象的初始化方式，称之为——"子类对象的隐式初始化"。
>
> ---
>
> 隐式对象初始化的必要条件：
>
> 1. **父类中有默认的构造方法**
> 2. 子类的构造器中没有显式使用super调用父类的构造方法，也没有用this去调用自己的构造方法。
>
> 达成上述两个条件，则JVM在初始化子类对象时进行隐式初始化，永远先执行父类的构造方法，顺序为：
>
> 1. 最上层的父类（Object）
> 2. 其他父类（继承链中越处于上流越先执行）
> 3. 所有父类的构造方法都执行完毕，开始执行子类构造方法

> `>(green)`
>
> 注意事项：
>
> - 隐式初始化，JVM总是调用父类的无参构造，如果父类没有，就要编译报错。所以，之前我们说给一个类顺手提供默认无参是一个好习惯，就在于这里。
> - Object类也有默认无参。
> - 隐式初始化总是不传参数，如果我们想要对参数进行赋值，就必须使用显式的子类初始化。

# 显式子类对象初始化

> `>(red)`
>
> 子类对象的隐式初始化是调用父类无参构造方法，所以如果需要给父类成员变量直接赋值是做不到的， <span style=color:red;background:yellow>**所以就需要子类对象的显式初始化。即明确在子类构造器的第一行，用super(参数)，明确指出调用父类的某个构造方法来完成父类成员变量的赋值。**</span>
>
> 语法：
>
> ``` java
> super(参数);
> ```
>
> > 注意事项：
>
> 1. super在构造器中用于表示调用父类构造器时，例如super(参数)，该条语句必须在第一行。
> 2. this在构造器中用于表示调用自身构造器时，例如this(参数)，该条语句必须在第一行。
> 3. 显然super、this两个关键字在表示调用构造器时，是绝不可能共存的。

# super关键字

> `>(red)`
>
> > 什么是super关键字？
>
> 上面其实已经说过了，你完全可以直接把super关键字，看成指向当前类的父类"对象"的一个引用。即：
>
> 1. this代表当前类的当前对象。
> 2. super表示当前类的父类对象。
>
> ---
>
> super和this的使用几乎没有差别，只不过一个表示子类对象，一个表示父类对象。比较大的区别是：
>
> 1. super只能访问父类中有的成员，特殊情况下，当父子类具有同名成员时，可以用super区分。
> 2.  <span style=color:red;background:yellow>**this在当前类中不受访问权限控制，super访问父类成员，受访问权限控制。**</span>
>
> 具体的使用可以参考下面表格：
>
> ###### this VS super
>
> | this  | 当前对象的引用         | this(参数)  |  this.   |       否       |
> | :---: | ---------------------- | :---------: | :------: | :------------: |
> |       | 含义                   | 构造器调用  | 成员访问 | 是否受权限控制 |
> | super | 父类对象（近似）的引用 | super(参数) |  super.  |       是       |

# 小练习

> `>(green)`
>
> 分析程序的执行顺序：
>
> ###### 小练习
>
> ``` java
> public class Demo {
>  public static void main(String[] args) {
>      PrimaryStudent primaryStudent = new PrimaryStudent(666,888,"hello");
>      System.out.println(primaryStudent.psVar);
>  }
> }
> class Person {
>  static {
>      System.out.println("Person类加载");
>  }
>  {
>      System.out.println("Person构造代码块");
>  }
>  public Person() {
>      System.out.println("Person类的无参构造");
>  }
> }
> class Student extends Person {
>  static {
>      System.out.println("Student类加载");
>  }
>  {
>      System.out.println("Student构造代码块");
>  }
>  int sVar;
>  String sVarString;
>  public Student() {
>      System.out.println("Student类无参构造");
>  }
>  public Student(int sVar) {
>      System.out.println("Student int构造方法");
>      this.sVar = sVar;
>  }
>  public Student(int sVar, String sVarString) {
>      this(sVar);
>      System.out.println("Student int String构造方法");
>      this.sVarString = sVarString;
>  }
> }
> class PrimaryStudent extends Student {
>  static {
>      System.out.println("PrimaryStudent类加载");
>  }
>  {
>      System.out.println("PrimaryStudent构造代码块");
>  }
>  int psVar = 10;
>  public PrimaryStudent(int psVar, int sVar, String sVarString) {
>      super(sVar, sVarString);
>      System.out.println("PrimaryStudent类的 三参构造");
>      this.psVar = psVar = 100;
>  }
> }
> ```
>
> 先父后子，父类构造器执行完毕，才能轮到子类。当然父类如果有多个，就从最顶层父类开始。

# 总结

> `>(green)`
>
> 总结：
>
> **无论是隐式还是显式，最终都是为了保证父类构造器先于子类执行。**
>
> 
>
> ---
>
>  <span style=color:red;background:yellow>**总结一下到目前为止，创建对象过程中可能碰到的结构的执行顺序（最全）：**</span>
>
> 我们将程序的运行分成两部分：
>
>  <font color=red>**第一部分：类加载**</font>
>
> 1. 首先程序要从main方法启动，这意味着首先要触发，装有main方法的那个类的类加载。
>
>    类加载过程中，一定要考虑连环触发类加载的情况：
>
>    1. 类中有静态成员变量创建对象，那么一定会触发其它类的类加载。
>    2. 该类还有父类，于是触发父类类加载。
>
> 2. 类加载这个过程中，静态代码块的代码一定会执行，不要忘记了。
>
> 3. 如果有静态成员变量的显式赋值，那么显式赋值和静态代码块，按照代码的书写顺序从上往下执行。
>
> 4. 类加载整个程序运行期间只有一次，如有通过继承连环触发类加载，那么顺序是`先父后子`，从最顶层父类开始。
>
>  <font color=red>**第二部分：创建对象**</font>
>
> 1. 切记类加载是懒加载，有些类可能等到main方法执行到一半才触发类加载。
>    - 这个就要随机应变了，以下步骤，都默认类加载全部结束了。
> 2. new对象时，首先去找到new对象的构造器，然后观察第一行
>    1. 如果它的首行显式地调用了另一个构造器（可能是`this(参数)`，也可能是`super(参数)`）
>       - 那么程序会先跳转到那个构造器，再去看代码首行有没有显式调用另一个构造器
>         - 直到找到一个构造器它隐含的super()指向Object类的无参构造
>         - 于是开始按照这个类中构造代码块和显式赋值的代码书写顺序，从上到下执行其中的代码
>         - 最后执行这个类的构造器
>       - 开始执行被跳转的构造器，同样先执行显式赋值和构造代码块后执行构造器
>       - 最后执行完new对象构造器，创建对象过程结束。
>    2. 如果它的首行没有显式调用另一个构造器，那么必定隐含`super()`指向父类的无参构造器。
>       - 如果直接指向Object类的无参构造，那十分简单，直接不用管
>         - 执行类中的显式赋值和构造代码块，最后执行构造器
>       - 如果指向一个普通父类的无参构造，那就观察首行，根据情况执行步骤a或b
>       - 最终一定父类构造器执行完毕，回到new对象的类中，执行完毕new对象构造器，创建对象过程结束。
>
> ----
>
> 总之，`先父后子`记住，在某一个类中成员变量赋值中，构造器最后去执行。

###### The End
