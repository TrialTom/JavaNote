###### <sub><font color = orange>JAVASE基础教程</font></sub><br />——<br /><sup><font color=white>卷5</font></sup><font color=white>面向对象设计</font><br/><sup><sub><font color=cyan>节1</font></sub><font color=cyan>抽象类</font></sup><br/><br/>	``#最新版本|V1.0#(purple) ``<br/>**长风**<br/>*COPYRIGHT ⓒ 2021. 王道版权所有*

[TOC]

# 抽象类的引入

> `>(green)`
>
> 以下猫狗继承案例，是一个非常基础的继承语法的代码。思考一下Animal类的继承体系，有什么问题吗？
>
> 从以下两个角度分析：
>
> 1. 从代码角度上，有没有冗余代码？
> 2. 从设计角度上，在这个案例中，会存在一个`动物`对象吗？
>
> ###### 猫狗继承的案例
>
> ``` java
> class Animal {
>     public void shout() {
>         System.out.println("动物叫");
>     }
> }
> class Cat extends Animal {
>     @Override
>     public void shout() {
>         System.out.println("猫叫");
>     }
> }
> class Dog extends Animal {
>     @Override
>     public void shout() {
>         System.out.println("狗叫");
>     }
> }
> ```
>
> 分析一下
>
> 1. 单纯从代码角度上，有没有冗余代码？
>
>    实际上是有的。从方法调用的角度考虑，Animal类当中的shout方法从来没有被调用过。该方法单纯就是让子类继承并重写的，它实际上没有被调用的需求。从最理想的角度上来说，它的方法体是可以去掉的，仅保留一个声明让子类去重写就可以了。
>
> 2. 当然代码多几行少几行并不重要，重要是：从设计角度出发，Animal类是一个抽象的概念，用于指代所有动物。程序中根本不需要创建它的对象。而且对于一个抽象的概念，也不应该、也不可能去描述它的行为。
>
> 综上，我们提出两个改进的方向：
>
> 1. Animal类就是作为顶层抽象祖先类而存在的，不需要创建对象，于是干脆不要创建对象了。
> 2. Animal类当中的shout方法不需要方法体，仅用于作为被继承和重写一个方法声明。

# 抽象类

> `>(red)`
>
> 按照上述构想我们首先把方法的方法体去掉，这样就得到一个抽象方法。它的语法是：
>
> ``` java
> [修饰符列表] abstract 返回值类型 方法名(形参列表);
> ```
>
> 注：
>
> 1. 抽象方法没有方法体，只有方法的声明（方法头）。但是不要忘记写分号";"。
> 2.  <span style=color:red;background:yellow>**抽象方法必须写在一个抽象类中。**</span>
>
> 接下来，我们定义抽象类。它的语法是：
>
> ###### 抽象类的定义语法
>
> ``` java
> [修饰符列表] abstract class 类名{
>     //类体
> }
> ```
>
> 通过测试，我们发现抽象类不能创建对象，但抽象类可以继承，存在子类。并且抽象类作为父类，多态现象仍然存在。

## 抽象类的定义

> `>(green)`
>
> <span style=color:red;background:yellow>**在继承体系中，从祖先类开始，随着一个个子类的定义，子类变得越来越具体，而祖先类则更具有一般性和抽象性。在这种情况下，为了体现祖先类在设计上的抽象性，我们只将该类作为派生其他类的父类，而不能创建对象实例。这个时候，这样的类，我们称之为抽象类。**</span>
>
> <img src="https://hixiaodong123.oss-cn-hangzhou.aliyuncs.com/typora/202201071337543.png?align=center" alt="抽象类继承图" style="zoom: 20%;" />
>
> **上层的类越来越抽象，下层的类越来越具体。**

## 抽象类的特点和使用

> `>(green)`
>
> > 自此，我们已经引入了抽象类的概念。接下来，我们重点来研究一个抽象类的特点和使用。
>
> 抽象类的特点我们主要从以下角度：
>
> ###### 抽象类的定义语法
>
> ``` java
> [修饰符列表] abstract class 类名{
>     //类体
> }
> ```
>
> 1. 类名命名特点
> 2. 能用哪些修饰符？
> 3. 成员特点
>    1. 普通成员
>    2. 静态成员
>    3. 抽象方法
> 4. 构造器
> 5. 代码块
>
> **抽象类的使用，我们主要探讨，它的子类特点。**

> `>(red)`
>
> 测试以后，结论如下：
>
> 1. 抽象类仍然是一个类，它的命名仍然需要遵循大驼峰的命名规范。当然，它比较特殊，许多公司的开发规范中，会要求将抽象类命名为`AbstracXxx`或`BaseXxx`，用于表示该类是一个抽象类。这是一个不错的命名习惯，推荐使用，但不强制。
>
> 2. 类class在定义时，本身可以使用的修饰符就比较少，除了访问权限修饰符之外，几乎就只有final、abstract等少数修饰符。但是但是final和abstract在修饰类时是冲突的，不能放在一起使用。final是阻止继承而abstract是抽象类，如果不继承抽象类没有任何意义。
>
> 3. 抽象类的成员特点：
>
>    1. 成员变量。抽象类可以定义普通类中能够定义的所有成员变量，在这一点上，和普通类是一样的。
>
>    2. 成员方法。抽象类可以定义普通类中能够定义的所有成员方法，包括普通成员方法和静态成员方法，在这一点上，和普通类仍然是一样的
>
>       注：抽象类虽然不能创建对象，但是它有子类，这些具体实现方法可以让子类继承，子类可以选择直接使用，也可以选择重写，选择的权力在子类手上（假如一个方法在抽象类的多个子类中都需要被使用，那么就可以提取到抽象类中作为一个默认实现）
>
>       综上，不能发现： <span style=color:red;background:yellow>**普通类中能够定义的成员，在抽象类中都是可以定义的。**</span>
>
>    3. 抽象方法。首先抽象类可以没有抽象方法，但是如果一个抽象类没有抽象方法，那么它就没有必要声明为抽象，直接声明为普通类就够了。<font color=red>**定义出一个抽象类，就是为了定义抽象方法的。**</font>抽象方法最重要的作用是起到 <span style=color:red;background:yellow>**"占位"**</span> 的作用，任何普通类继承了该抽象类，都必须实现该抽象方法（强制的）
>
>       如果子类不想实现抽象父类中的抽象方法，可以把子类也设置为抽象类，抽象类就不需要实现父类中的抽象方法了。
>
> 4. 构造器。构造器除了可以自己用，创建对象时给成员变量赋值，还可以给子类用，在子类对象初始化过程中，可以调用父类的构造方法给父类的成员变量赋值。所以抽象类虽然不能创建对象，但它也是有构造器的。实际上，<span style=color:red;background:yellow>**在Java中，任何一个类都有构造器。**</span>
>
> 5. 代码块，无论是构造代码块，还是静态代码块，都有。
>
> 综上：抽象类实际上和普通类能够定义的成员是一样的，普通类中有的东西它都有，只不过多了一个抽象方法。<span style=color:red;background:yellow>**在不考虑创建对象的情况下，直接把一个类声明为abstract，是不会编译报错的。**</span>
>
> ---
>
> 抽象类的子类可以有两种情况：
>
> 1. 普通类，普通类继承抽象类，必须实现所有的抽象方法。
> 2. 抽象类，抽象子类不需要实现抽象方法，抽象子类可以自由选择实现（或实现或不实现）。
>
> 注：抽象类还可以继承一个普通类，但这很罕见，知道即可。

# 注意事项

> `>(red)`
>
> 1. abstract关键字，不能用来修饰构造器、属性、代码块等结构。只能修饰类或者方法。
>
> 2. abstract修饰类时，类的修饰符不能有final。
>
> 3. abstract修饰方法时，该方法不能有修饰符：
>
>    1. private
>    2. static
>    3. final
>
>    当然abstract修饰符也不能修饰构造方法
>
> 4. 一个抽象类中可以没有抽象方法，但是意义不是很大<font color=red>**（普遍来说，抽象类就应该有抽象方法）**</font>

# 小试牛刀

> `>(red)`
>
> 1. 编码练习
>
> > 公司正在开发一套员工管理系统，需要对公司内部存在的员工进行管理
> >
> > 公司将员工分为三类，普通员工负责杂项工作，程序员负责技术开发，经理负责统筹规划
> >
> > 普通员工包含3个属性：姓名、工号以及工资，行为是工作
> >
> > 程序员包含3个属性：姓名、工号以及工资，行为是工作和加班（overtime work）
> >
> > 经理包含4个属性：姓名、工号、工资以及奖金（bonus），行为是工作
>
> - 请使用所学的知识设计该员工系统
> - 要求类中提供必要的方法进行属性访问（description）
>
> 2. 抽象类的作用是：做为继承体系中的顶层父类、祖先类而存在的。说白了所有继承了该抽象类的对象，都应该是一个该抽象类的对象。比如我定义了一个抽象的Person类，那么Student、Teacher等继承它是没问题的，但是让一个Cat继承就不行了（即便有成员可以复用）。<font color=red>**只要是继承，就必须考虑"is-a"关系。**</font>

###### The End