###### <sub><font color = orange>JAVASE基础教程</font></sub><br />——<br /><sup><font color=white>卷5</font></sup><font color=white>面向对象设计</font><br/><sup><sub><font color=cyan>节2</font></sub><font color=cyan>接口</font></sup><br/><br/>	``#最新版本|V2.1#(purple) ``<br/>**长风**<br/>*COPYRIGHT ⓒ 2021. 王道版权所有*

[TOC]



# 接口的引入

> `>(green)`
>
> 在之前的猫狗案例中，我们将Animal类设置为抽象类，继承体系代码如下：
>
> ###### 猫狗案例代码
>
> ``` java
> abstract class Animal {
>  public abstract void shout();
> }
> class Cat extends Animal {
>  @Override
>  public void shout() {
>      System.out.println("猫叫");
>  }
> }
> class Dog extends Animal {
>  @Override
>  public void shout() {
>      System.out.println("狗叫");
>  }
> }
> ```
>
> 现在我们有了新需求：一部分猫和狗，经过了特殊训练，能够直立行走了。那么这群特殊的猫和狗，怎么描述它们呢？
>
> > 分析：
> >
> > 部分猫和狗经过特殊训练，才能够直立行走。所以不可能直接加个方法到Cat类和Dog类中，不是所有猫狗都有这个行为。而特殊的猫狗仍然是猫和狗，所以它们肯定还要继承猫和狗这两个类。可能很多同学，这时候想到的就是：重新定义两个新的猫狗类（比如超级狗和猫）继承猫狗，然后给出直立行走的方法就算完事了。这样做不是不行，需求是实现了，但还有一些小问题：
> >
> > 1. 一方面没有体现代码复用。
> > 2. 更重要的是，没有体现出`特殊训练`的过程。假如还有一些动物也要直立行走，增加这个行为，如何体现出规范性、标准性呢？体现出它们是特殊的经过训练的动物呢？
> >
> > 这里我们想到了抽象类，因为抽象类中抽象方法，可以强制约束子类实现它，这样就是一种标准和规范，体现了它经过了特殊训练，和之前不同了。
> >
> > 于是我们定义抽象类，给出抽象方法，让超级猫狗类去继承这个抽象类，可行吗？
> >
> > 理想很美好，现实很骨感。显然做不到，因为Java不支持多继承。除开这点这么做也不是完美的，问题是：
> >
> > 1. **这个抽象类里面是对功能和行为的抽象，缺少属性（单独一个直立行走的行为是一个什么对象？）所以单独的行为不应该被抽象为类，不符合类的定义。**
> > 2. **继承这个抽象类也不符合继承的"is-a"关系，这里不适用继承（还是上面那句话，行为根本不是个体）**
> >
> > 于是，我们就迫切需要一种全新的数据类型，这种全新的数据类型：
> >
> > 1. <span style=color:red;background:yellow>**不强调属性，只强调行为的抽象，"继承"它表示功能的扩展。**</span>
> > 2.  <span style=color:red;background:yellow>**在一个类继承某个类后，还能继续"继承"，不受Java单继承限制。**</span>
> > 3.  <span style=color:red;background:yellow>**没有"is-a"这种继承关系的限制。**</span>
> > 4.  <font color=red>**最好还有抽象方法。（因为它能表示规范和标准）**</font>
>
> 这种全新的数据类型，就是接口（interface）。

# 接口的定义

> `>(green)`
>
> 上面四条，其实已经描述了接口的特点，接口是一种表示对`行为抽象`的，不受Java多继承限制的，用来作为功能扩展标准的一种引用数据类型。它的定义语法如下：
>
> ``` java
> [访问权限修饰符] interface 接口名{}
> ```
>
> 注：
>
> 1. 接口的访问权限修饰符也只有两种：
>
>    1. public 
>    2. 默认缺省的
>
>    含义也是一模一样的
>
> 2. 接口名和类名一样，遵循大驼峰式的书写规范，接口名最好起的`见名知意`。有些程序员喜欢在接口前加一个大写字母`I`来直接，表示该类型是一个接口，可以借鉴，但不强制。
>
> 4. 接口中可以定义抽象方法，和抽象类中定义抽象方法没有区别。
>
> 5. 接口是可以被一个类"继承"的，接口的"继承"，更准确、常见的叫法称之为<span style=color:red;background:yellow>**接口的实现**</span>。当然它也不再使用extends关键字，而是使用 <span style=color:red;background:yellow>**implements**</span> 关键字。一个普通类实现接口必须实现所有抽象方法。它的语法是：
>
>    ``` java
>     [访问权限修饰符] class 类名 extends 类名 implements 接口名 {}
>    ```
> 
>    细节问题：**如果一个类实现接口并继承别的类，要"先继承再实现"。**关键字位置不要写反了。
>
> 6. 在接口的实现中，可以称呼接口为"父接口"，接口的实现类为"子类"，它们仍然是父子关系。当然多态现象仍然能够发生。
>
> 7. 接口不受多继承限制，一个类可以在继承别的类的同时实现接口，而且可以实现多个接口。
>

# 使用接口的优点

> `>(red)`
>
> 使用接口有如下优点：
>
> 1. 接口不受单继承限制，这是接口非常重要的优点。
> 2. 接口不是类，它和它的实现类，也不需要存在"is-a"关系，接口比抽象类的使用更加灵活。
>    - 程序开发中将接口和它的实现类之间的关系，称之为"like-a"关系。只要是实现了Xxx的功能，就像Xxx。
> 3.  <span style=color:red;background:yellow>**接口表示一种开发标准，一种规范。表示对功能的扩展，它只关注行为，不关注属性。**</span>

# 接口的成员特点和使用

> `>(green)`
>
> > 自此，我们已经引入了接口的概念。接下来，我们重点来研究一个接口的特点和使用。
>
> 接口的特点我们主要研究以下方面
>
> 1. 接口的声明特点
> 2. 接口的实现类的书写格式
> 3. 成员特点
>    1. 普通成员
>    2. 静态成员
>    3. 抽象方法
> 4. 构造器
> 5. 代码块
>
> **接口的使用，我们主要探讨它的子类特点。**

> `>(red)`
>
> **测试后，我们的结论是：**
>
> 1. 接口显然是不能声明为final的，因为final是阻止继承，而接口不被实现毫无意义。接口天生就是abstract修饰的，也就是说接口定义语法的修饰符列表中隐含了`abstract`。 <span style=color:red;background:yellow>**当然接口也不能创建对象。**</span>
>
>    1. 接口中的成员变量默认都是public static final修饰的公共的全局常量。
>
>
>    注：
>
>    1. public是不可更改的，不能用别的修饰符。
>    2. public static final都是隐含的，不要写出来。
>    3. 接口中的全局常量必须显式赋值，不能用静态代码块赋值，因为接口没有静态代码块。
>    4. 接口侧重于行为，功能的扩展，绝大多数接口中都是没有全局常量的，都只有方法。
>    4. <span style=color:red;background:yellow>**假如你有一个全局常量，需要在每一个接口实现类中被使用，那么可以提取出来，放进接口中。**</span>当然，这种需求不多见。
>
> 2. 在Java8之前，接口中的方法默认都是public abstract修饰的成员方法，即只能定义抽象方法。
>
> 3. 接口没有构造方法，没有构造代码块，也没有静态代码块。
>
>    两个问题:
>
>    1. **实现接口的类，如果没有明确继承一个其他类，那么子类对象的隐式初始化super()指向Object类。**
>    2. **接口虽然不是类，但是它也继承了Object类。**
>
> 4. 接口的子类特点：
>
>    接口的子类可以是什么？
>
>    1. **普通类实现接口，必须实现所有的抽象方法。**
>    2. **抽象类实现接口，按需实现抽象方法。**
>    3. **接口可以继承一个接口，按需实现抽象方法的。**
>
> 5. 总结一下，接口和类的继承/实现的规则：
>
>    1. <font color=red>**继承（extends）是不能跨越种族的，类和类继承，接口和接口继承，接口和类之间没有继承关系。**</font>
>       - 普通类继承一个抽象类，需要实现里面的所有抽象方法。
>       - 抽象类继承一个抽象类，按需实现里面的抽象方法。
>       - 抽象类继承一个普通类，是可以的。
>       - 接口在继承一个接口后，会得到接口的所有抽象方法。
>       -  <span style=color:red;background:yellow>**类的继承是单继承的，接口的继承是多继承的。**</span>
>    2.  <font color=red>**实现（implements），必须发现在类与接口之间，接口和类是没有任何关系的。**</font>
>       - 普通类实现接口，必须实现所有抽象方法
>       - 抽象类实现接口，按需实现抽象方法

# （附）Java8中的默认方法和静态方法

> `>(green)`
>
> Java8中接口的语法迎来了大的变动，新增了两种具有方法体的实现方法：
>
> 1. 默认方法。
>
>    语法：
>
>    ###### 默认方法的语法
>
>    ``` java
>    // 默认方法的语法:
>    default 返回值类型 方法名(形参列表){
>        //方法体
>    }
>    ```
>
>    1. 接口中的默认方法的访问权限修饰符是public，不可更改。
>    2. 默认方法的作用：
>       - 抽象类中的实现方法是用来作为子类的默认实现的，但是接口不具备这个功能。接口表示对功能的扩展，它更多的是一种标准和规范，多数情况下它不需要实现方法。
>       - Java8仍然新增了默认方法，主要是两个角度考虑:
>         - 接口中一旦有了默认实现方法，程序设计接口的灵活性就增加了。在没有默认方法时，接口中一旦新增任何方法，子类都必须实现它。而现在有了默认方法，就不需要这么做：
>           - 需要实现的就自己重写，不需要的就直接继承。代码的兼容性和灵活性就增加了。
>         - Java8中引入了`Lambda表达式`和`StreamAPI`，接口中的默认方法可以作为它们的实现，完成函数式编程。（这个仅了解，后面会讲Lambda表达式）
>       - 接口中的默认方法，还可以配合接口的"多实现"，实现真正意义上的多继承。
>
> 2. 静态方法。
>
>    语法：
>
>    ###### 接口中的静态方法语法
>
>    ``` java
>    static 返回值类型 方法名(形参列表){
>        //方法体
>    }
>    ```
>
>     1. 接口中的静态方法也是默认public修饰的，不可更改。
>     2. 它的调用方式是用接口名.静态方法名。
>     3. 接口中的静态方法也是为了配合`Lambda表达式`和`StreamAPI`使用的，其余场景不多见。
>     4. 接口自从Java8以后有了静态方法，甚至可以写一个main方法。
>     4.  <span style=color:red;background:yellow>**接口中的静态实现方法，只能自己用，不能用实现类类名调用。**</span>
>
> ---
>
> **上面两种方法仅供了解，实际开发中，可能会偶尔见到它，但自己写的概率非常小。**

# 注意事项

> `>(red)`
>
> 接口和抽象类的异同：
>
> ###### 接口 VS 抽象类
>
> | 编号 | **区别点** |                          **抽象类**                          |                 **接口**                  |
> | :--: | :--------: | :----------------------------------------------------------: | :---------------------------------------: |
> |  1   |    定义    |                       包含抽象方法的类                       |         抽象方法和全局常量的集合          |
> |  2   |    组成    |           构造方法、抽象方法、普通方法、常量、变量           | 常量、抽象方法、(jdk8:默认方法、静态方法) |
> |  3   |    使用    |                   子类继承抽象类(extends)                    |         子类实现接口(implements)          |
> |  4   |    关系    |                    抽象类可以实现多个接口                    |  接口不能继承抽象类，但允许继承多个接口   |
> |  5   |    对象    |                 不能创建对象，但是有构造方法                 |       不能创建对象，也没有构造方法        |
> |  6   |    局限    |                      抽象类不能被多继承                      |       接口之间能多继承，能被多实现        |
> |  7   |    思想    |             作为模板或对共性属性和行为抽象，is-a             |     作为标准或对共性行为抽象，like-a      |
> |  8   |  访问权限  |              抽象类的成员，写访问权限比较自由。              |      接口的成员，必须是public修饰的       |
> |  9   |    选择    | **如果抽象类和接口都可以使用的话，优先使用接口，避免单继承的局限** |                                           |
>
> 总之，抽象类和接口除了都是抽象外，区别相当明显。抽象类是作为继承层次中的顶层父类存在的，接口则比较自由。

# 小试牛刀

> `>(grenn)`
>
> 1. 教练（Coach）和运动员（Sportsman）案例
>
> > 小试牛刀请用所学知识分析：这个案例中有哪些抽象类，哪些接口，哪些具体类。
>
> 现在有乒乓球运动员和篮球运动员，乒乓球教练和篮球教练。为了能够出国交流，跟乒乓球相关的人员都需要学习英语。
>
> ---
>
> [-] interface在实际开发中的用途
>
> > 注：下文中，interface代表Java语法中的接口。
> >
> > 以后我们在公司中做开发，经常会听到前端小姐姐说：`大哥，接口提供一下呀！人家要测试一下嘛。`，也经常会听到后端老哥说：`兄弟，你不给我接口我很难办事啊！`。他们说的接口，其实和我们学的Java语法上的 <font color=red>**interface**</font> 就不太一样了，而是指的是广义上的`接口`，指的是<span style=color:red;background:yellow>**程序员开发出来，暴露给外界第三方使用的方法或者工具。**</span>
> >
> > 
> >
> > 这就好比于电脑上的接口，想象一下假如我们做好了一个 <span style=color:red;background:yellow>**符合协议**</span> 的USB-A接口，别人知道这个接口在哪后，拿来鼠标就能插上使用了。而电脑的USB-A接口的<span style=color:red;background:yellow>**协议**</span>，就是我们Java语法中的<span style=color:red>**interface**</span>，它是一个标准，是一个规范。
> >
> > 
> >
> > 在开发中，我们总会在写代码前，开一个简短的商讨会，叫上需要配合的前端程序员、后端程序员和产品经理等人，先把各自需要完成的业务进行分割，再商量出需要开发的接口。而**具体到实际接口的开发，则由接口的提供方和接口的使用方，商量出一套标准和规范。**这主要会包括，接口暴露出来的方法`需要的参数`，`返回的值`，`调用的方式`等。其中调用方式，一般多使用HTTPS协议进行网络传输，这是项目部署运维的事情，程序员大多不需要操心。那么接口方法`需要的参数`，`返回的值`这些怎么去规范呢？答：通过使用 <span style=color:red>**interface**</span> 来规范。
> >
> > 
> >
> > 实际上，多数普通的Java后端程序员，日常的开发就是围绕接口而展开的，俗称`写接口`。这些接口大多提供给前端直接使用，展示页面；也有些提供给其它后端开发，将数据封装一层，再做用途。总之开发中 <font color=red>**interface**</font> 的使用频率大大超过抽象类，下面看一个实例来练习一下。
>
> 2. 某电商系统`后台`，前端程序员需要后端程序员，提供接口来完成库存的管理，展示页面。**假如**前后端商量好，要求：
>    1. 展示全部商品（goods）页面时，将仅装有商品对象的数组返回，前端不提供任何数据。
>    2. 新增商品时，前端提供商品各种参数，后端需要校验ID唯一性，然后将对象插入数组，返回插入结果。
>    3. 删除商品时，前端提供商品ID，后端将该商品删除后，返回删除删除结果。（成功返回true，找不到该ID的商品返回false）
>    4. ....

# 方法的形参和返回值类型

> `>(red)`
>
> 在学习了抽象类，接口后，我们来系统研究一下方法的形参和返回值类型，在使用时的一些细节。

## 方法传值

> `>(green)`
>
> 方法的形参在方法调用传入实参时，不一定要求数据类型完全一致。
>
> 1. **基本类型：**对于基本数据类型的方法形参，存在自动类型提升。
> 2. **引用类型：** 对于引用数据类型的方法传参，存在自动向上转型。
>    1. 形参如果写一个普通类：调用方法时需要传入的是该类的对象或者该类的子类对象
>    2. 形参如果写一个抽象类：调用方法时需要传入的是该抽象类的子类对象
>    3. 形参如果写一个接口：调用方法时需要传入的是该接口的子类对象

## 方法的返回值

> `>(green)`
>
> 方法的返回值类型，和在方法体中返回具体值（对象）时，不一定要求数据类型完全一致。
>
> 1. **基本类型：**方法体中，返回一个具体的值不要求和返回值类型完全一致，存在自动类型提升。
> 2. **引用类型：** 在方法体中，返回一个对象时不要求就是返回值类型的对象，存在自动向上转型。
>    1. 返回值类型如果写一个普通类：可以返回该类的对象或者该类的子类对象
>    2. 返回值类型如果写一个抽象类：返回该抽象类的子类对象。
>    3. 返回值类型如果写一个接口：返回该接口的子类对象。

## 方法重写中的返回值类型问题

> `>(green)`
>
> 父子类方法重写中，方法声明中返回值类型的书写。
>
> 1. **基本类型和void：**必须保持一模一样，不存在类型提升。
> 2. **引用类型：**不必保持一模一样，存在自动向上转型。
>    1. 类：父类中的方法返回一个普通类类型
>       - 子类方法中可以返回该类型
>       - 也可以返回该类的子类类型
>    2. 抽象类：父类中的方法返回一个抽象类类型
>       - 子类方法可以返回该类型
>       - 也可以返回抽象类的实现类类型
>    3. 接口：父类中的方法返回一个接口类型
>       - 子类方法可以返回该类型
>       - 也可以返回接口的实现类类型

# 链式调用

> `>(green)`
>
> 链式调用，在Java代码中是很常见的。当然它不是一个语法，这里讲一下它的形式，大家知道即可。
>
> 对于类Studnet：
>
> ###### 链式调用Student类
>
> ``` java
> class Student{
> 
>     public Student getStudent(){
>         return new Student();
>     }
> 
>     public Teacher getTeacher(){
>        return new Teacher();
>     }
> }
> class Teacher{
>     public void show(){
>         System.out.println("秀一波~~~");
>     }
> }
> ```
>
> 假如在main方法中写以下代码（不使用链式调用）：
>
> ###### 不使用链式调用
>
> ``` java
> StudentDemo sd = new StudentDemo();
> Student s = sd.getStudent();
> s.show();
> ```
>
> 使用链式调用的形式为：
>
> ``` java
> new StudentDemo().getStudent().show();
> ```
>
>  <span style=color:red;background:yellow>**链式调用的本质在于：前面方法的返回值是一个对象。**</span>

###### 	The End
