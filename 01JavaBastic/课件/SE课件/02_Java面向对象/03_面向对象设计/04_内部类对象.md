###### <sub><font color = orange>JAVASE基础教程</font></sub><br />——<br /><sup><font color=white>卷5</font></sup><font color=white>面向对象设计</font><br/><sup><sub><font color=cyan>节4</font></sub><font color=cyan>内部类对象</font></sup><br/><br/>	``#最新版本|V1.0#(purple) ``<br/>**长风**<br/>*COPYRIGHT ⓒ 2021. 王道版权所有*

[TOC]

# 概述

> `>(green)`
>
> 本节内部类对象，本质上还是属于定义在别的类内部的一个类。但区别是： <font color=red>**成员内部类、静态内部类和局部内部类都属于定义了一个类，后续使用还需要基于内部类创建对象。而本节中的匿名内部类和Lambda表达式都是直接通过语法创建了对象。**</font>
>
> 其实想一想，我们定义内部类，最终还是为了获取对象使用，所以实际开发中匿名内部和Lambda表达式会更常见和常用。
>
> **最后，在学习匿名内部类和Lambda表达式之前，我们还是要清楚——它们都是特殊的局部内部类。所以一旦访问方法的局部变量，该局部变量需要是一个常量。**

# 匿名内部类

> `>(green)`
>
> 我们已经使用过匿名对象了，匿名对象的含义是这个对象是没有名字，没有引用指向它。**那么匿名内部类，指的就是这个内部类没有名字。**当然成员内部类和静态内部类没法没有名字，所以 <span style=color:red;background:yellow>**匿名内部类指的是"没有名字的局部内部类"。**</span>是一种特殊的局部内部类。

## 语法

> `>(green)`
>
> 在方法等局部位置，写下列语法，即表示定义匿名内部类：
>
> ###### 局部内部类的语法
>
> ``` java
> // 局部位置
> new 类名或者接口名(){
>   	// 某类名或接口名的子类的类体
> };
> // 局部位置
> ```
>
> 含义：
>
> 1. new表示创建对象，表示创建语法中**"类名/接口名"**的子类对象。
> 2. 这个语法结构，我们只知道这是一个子类对象，但这个子类到底叫啥，不知道，所以它是一个匿名类。当然匿名内部类更准确的说法，应该叫`匿名内部类对象`。
> 3.  <span style=color:red;background:yellow>**匿名内部类的本质是，一个继承了类或者实现了接口的匿名子类对象。**</span>

## 基本使用

> `>(green)`
>
> 匿名内部类是特殊的局部内部类，它的成员特征、访问特征和局部内部类没有区别。这里不再赘述。
>
> 这里我们直接说明一下，匿名内部类对象的两种使用方式：
>
> 1. 可以直接在后面调用方法，访问它的成员（当一个匿名对象使用）
>    1. 优点是：
>       - 可以访问子类独有的成员。
>       - 方便快捷，不需要用引用接收再去使用。
>    2. 缺点是：
>       - 一次性，仅能用一次
> 2. 可以用**（父）**引用接收对象，然后再用引用访问成员
>    1. 优点是：
>       - 可以用多次
>    2. 缺点是：
>       -  <span style=color:red;background:yellow>**不能访问子类独有成员（真的无法访问，无法强转，因为子类已经匿名了)**</span>
>
> 综上，两种使用方式场景不同。如果有多次使用需求，就需要父引用接收；反之如果仅用一次，或者需要访问子类独有成员，就必须直接使用，不能用引用接收。

## 使用场景

> `>(green)`
>
> 匿名内部类实际上就是更简单的局部内部类（直接获取了对象），所以局部内部类的使用场景，可以直接套用过来。
>
> 匿名内部类经常使用在以下两个场景中：
>
> 1. 方法需要返回一个对象，返回值类型是引用数据类型时。
>
>    方法需要返回一个对象时，可以在方法的局部位置写一个 <font color=red>**基于X类或X接口的匿名内部类对象**</font> ，然后直接作为返回值返回给外界。
>
> 2. 方法需要传入一个对象，形参数据类型是引用数据类型时。
>
>    方法需要传入一个对象实参时，可以在调用方法的**实参位置**填入一个 <font color=red>**基于X类或X接口的匿名内部类对象**</font>，就将它作为一个实参传给方法使用。
>
> 使用匿名内部类的优点：
>
> 1. 绝对对外界隐藏，封装。
> 2. 比起局部内部类，它更方便简洁了。所以实际开发中，匿名内部类基本取代了局部内部类的作用。
>
> 缺点：
>
> 1. 这个对象是一次性的。
>
> 总之，酌情使用匿名内部类对象，可以简化代码书写，方便省事。但不要为了使用而使用，假如存在多个场景都需要一个子类对象，那还是直接创建一个子类出来好了。

## 牛刀小试

> `>(red)`
>
> 不修改main方法和接口Inter的前提下，补齐Outer类代码，要求在控制台输出`HelloWorld`
>
> ###### 匿名内部类的练习
>
> ``` java
> public class Test{
>     public static void main(String[] args) {
>         Outer.method().show();
>     }
> }
> interface Inter {
>     void show();
> }
> class Outer {
>     
> }
> ```

# Lambda表达式

> `>(green)`
>
> Lambda 表达式是 JDK8 的一个新特性，可以取代接口的匿名内部类，写出更优雅的Java 代码。
>
> 如果说匿名内部类实际上是局部内部类的更进一步，简化了局部内部类，那么Lambda就是匿名内部类更进一步，语法上更简洁了，代码更优雅了，是高端的玩法，是人上人的玩法。
>
> 以上描述总体就说了三点：
>
> 1. .Lambda表达式仍然是局部内部类，是特殊的局部内部类，仍然定义在局部位置。而且局部内部类的注意事项，也一样存在。
> 2. Lambda表达式在取代匿名内部类时，不是全部都取代，而是取代接口的匿名内部类，而类的匿名内部类Lambda表达式是不能取代的。
> 3. Lambda表达式是匿名内部类的更进一步， <span style=color:red;background:yellow>**Lambda表达式得到的也不是一个类，而是一个对象，并且是接口的子类对象。**</span>

## 使用前提

> `>(green)`
>
> Lambda表达式虽然说是取代接口的匿名内部类，但也不是什么接口都能用Lambda表达式创建子类对象。
>
>  <span style=color:red;background:yellow>**Lambda表达式要求的接口中，必须有且仅有一个必须要实现的抽象方法。这种接口在Java中，被称之为"功能接口"。**</span>功能接口在语法上，可以使用注解`@FunctionalInterface`标记在接口头上，用于检测一个接口是否是功能接口。
>
> 例如：
>
> ###### 注解@FunctionalInterface
>
> ``` java
> @FunctionalInterface
> interface IA{
>   void test();
> }
> ```
>
> 上述代码中`IA`接口就是一个功能接口，注解就不会编译报错，反之就会编译报错。这有点类似于@Override注解对方法重写的检验。
>
> ---
>
> 看完上述关于功能接口的语法定义，思考两个问题：
>
> 1. 功能接口中只能有一个方法吗？
> 2. 功能接口中只能有一个抽象方法吗？
>
> 答：
>
> 1.  不是，Java8中的默认方法和静态方法不需要子类实现，功能接口中可以允许有它们存在。
>
> 2. **不是，有极个别比较特殊的抽象方法，可以不需要子类实现。**
>
>    注：Object类是Java每一个类的父类，所以Object类当中的方法实现就可以作为接口抽象方法的实现。比如：
>
>    ###### 功能接口不仅有一个抽象方法
>
>    ``` java
>    @FunctionalInterface
>    interface IA{
>      void test();
>              boolean equals(Object obj);
>    }
>    ```
>    
>接口`IA`仍然是一个功能方法，因为抽象方法`boolean equals(Object obj);`可以直接使用Object类中的实现，无需子类实现。
> 
>所以，再强调一下，功能接口指的是，有且仅有一个必须要子类实现的抽象方法的接口。

## 基本使用

> `>(green)`
>
> 功能接口准备完毕后，就可以写Lambda表达式的语法，表示创建功能接口的子类对象了。当然Lambda表达式是特殊的局部内部类，仍然要写在局部位置。
>
> 它的语法是：
>
> ###### Lambda表达式语法
>
> ``` java
> (形参列表) -> {
>  // 方法体
> }
> ```
>
> 解释一下：
>
> 1. `(形参列表) `表示功能接口中，必须要重写的抽象方法的形参列表。
> 2. `->`由一个`英文横杠 + 英文大于号`字符组成，它是Lambda表达式的运算符，读作`goes to`。
> 3. `{ //方法体 }`表示功能接口中，必须要重写的抽象方法的，方法头实现。
>
> 其实，看完这个Lambda表达式的语法定义，就已经能够解释为什么Lambda表达式，要求接口有且只有一个必须要实现的抽象方法了。<font color=red>**因为语法中仅有一套形参列表和方法体，只能重写一个方法。**</font>
>
> 而且，这个语法写出来，很明显<font color=red>**Lambda表达式只能重写父接口中的抽象方法，是不能自己新增成员的！**</font>
>
> ---
>
> 在方法等局部位置，写上述语法后，肯定会报错。原因在于Java是强类型语言，任何变量都有它的数据类型，而直接写Lambda表达式语言，编译器是无从得知它的数据类型的——**这个Lambda表达式创建了接口的子类对象，到底是哪个接口的子类对象呢？**
>
> 所以我们需要帮助编译器，明确Lambda表达式所表示的对象的类型，这个过程称之为 <span style=color:red;background:yellow>**"Lambda表达式的类型推断"**</span>。
>
> 怎么推断呢？在这个推断过程中，需要给编译器提供额外的信息，告诉它Lambda表达式是哪个接口的子类对象。总得来说，常见和常用的有以下三种方式：
>
> 1. **直接用父接口引用接收。**由于Lambda表达式表示的子类对象并没有自己独有的成员，所以直接用父类引用接收完全不会有任何问题。
>
> 2. **不用引用接收，但是要直接告诉编译器Lambda表达式是哪个接口的子类对象，语法上有点像强转（但不是）。**
>
>    语法：
>
>    ``` java
>    ((父接口的名字)Lambda表达式).方法名(实参)
>    ```
>
>    这种方式有点类似于匿名对象，所以必须直接调用方法，不然会编译语法报错。
>
> 3. **借助方法完成类型推断。**
>
>    1. 可以借助方法的返回值数据类型完成类型推断，因为方法的返回值编译器已经知道该返回什么对象。
>    2. 可以借助方法的形参的数据类型完成类型推荐，因为方法的实参编译器已经知道该传入什么对象。
>
> ---
>
> 以上，Lambda表达式最基础使用，就完成了。

## 进阶使用和简化

> `>(red)`
>
> 为了方便语法练习，这里给出六个功能接口：
>
> ###### 功能接口案例
>
> ``` java
> //无返回值无参数的功能接口
> @FunctionalInterface
> interface INoReturnNoParam {
>     void test();
> }
> 
> //无返回值有一个参数的功能接口
> @FunctionalInterface
> interface INoReturnOneParam {
>     void test(int a);
> }
> 
> //无返回值两个参数的功能接口
> @FunctionalInterface
> interface INoReturnTwoParam {
>     void test(int a, int b);
> }
> 
> //有返回值无参数的功能接口
> @FunctionalInterface
> interface IHasReturnNoParam {
>     int test();
> }
> 
> //有返回值一个参数的功能接口
> @FunctionalInterface
> interface IHasReturnOneParam {
>     int method(int a);
> }
> 
> //有返回值两个参数的功能接口
> @FunctionalInterface
> interface IHasReturnTwoParam {
>     int test(int a, int b);
> }
> ```
>
> 接下来，我们基于上述功能接口，讲解一下Lambda表达式的进阶使用， <font color=red>**主要就是格式的简化。**</font>

> `>(green)`
>
>  <span style=color:red;background:yellow>**Lambda表达式能够简化的前提是：它是功能接口的子类对象，而功能接口中有且只有一个必须要实现的抽象方法！**</span>
>
> 基于下列Lambda表达式的语法：
>
> ###### Lambda表达式的语法
>
> ``` java
> (形参列表) -> {
>     // 方法体
> }
> ```
>
> 逐个部分简化：
>
> 1. `(形参列表)`能不能简化呢？是可以的，因为功能接口中有且仅有一个必须要实现的抽象方法，那么：
>
>    1. 形参的数据类型是可以省略的，因为方法已经固定死了，形参一定是那些，不需要写出来。但形参的名字是不可省略的（因为要在方法体中使用）
>    2. 特殊情况下：
>       - 如果形参列表中的形参只有一个，那么`()`小括号，也是可以省略的。
>       - 但是如果形参为空，`()`小括号是不可以省略的。
>
> 2. `{ //方法体 }`方法体能不能简化呢？当然是可以的：
>
>    1. **如果方法重写的方法体只有一条语句的话，那么可以省略大括号。（类似于if/for省略大括号）**
>    2. **特殊的，如果只有一条语句且这条语句是返回值语句，那么大括号和return可以一起省略。**
>
> 3. 实际上在多数情况下，都不太可能一句话把方法体写完。多数情况下，Lambda表达式的抽象方法实现都会很复杂，那这样Lambda表达式就会写的很复杂，这就很难受了。而Lambda表达式，本质上就是重写了一个抽象方法的子类对象，所以Java允许<span style=color:red;background:yellow>**Lambda表达式的抽象方法的实现可以直接指向一个已经存在的方法，而不是自己书写实现。这种语法在Java中称之为"方法引用"！**</span>
>
>    那么这里就有一个很重要的问题了：什么样的方法，能够作为`方法引用`指向的功能接口中抽象方法的实现？只看三点：
>
>    1. 返回值类型必须一致。
>    2. 形参列表中的数量，类型，位置必须都对应上，形参名字无所谓。
>    3. 方法的名字无所谓。
>
>    有了具体实现的方法，那么实现`方法引用`的语法，有两种方式：
>
>    1. 不去掉运算符的格式：
>
>       ``` java
>       (形参列表) -> 已实现的方法(形参列表);
>       ```
>
>       注：如果是同类中直接写方法名即可，如果不是同类，就必须要指出方法来自哪里（通过类名或对象名访问）
>
>       普通成员方法写对象名点，静态方法写类名点。
>
>    2. 去掉运算符，最简单的形式：
>
>       ``` java
>       功能接口 引用名 = 方法的归属者::方法名;
>       ```
>
>       以上就是一个Lambda表达式，就直接能够表示某个接口的子类对象。
>
>       如何判断方法的归属者呢？
>
>       - 静态方法，属于类，需要写`类名::`。
>       - 成员方法，属于对象，需要写`对象名::`。
>
> ---
>
> 以上Lambda表达式的使用，就基本结束了，在后面的学习中，我们会结合具体场景再去使用Lambda表达式。这里我们就不再赘述了，大家先了解语法就可以了。

## 注意事项

> `>(green)`
>
> Lambda表达式是特殊的局部内部类，所以它访问方法的局部变量，该变量必须是final的（实际常量）。
>
> 除此之外，局部内部类，匿名内部类它们都有自己独立的作用域，能够自定义自己的成员。 <span style=color:red;background:yellow>**但是Lambda表达式没有自身独立的作用域，不能自定义成员，和方法共用同一个作用域。**</span>
>
> 比如下列代码是会编译报错的：
>
> ###### Lambda表达式没有自身作用域
>
> ``` java
> int a = 10;
> INoReturnOneParam ip = a -> System.out.println("a的值是:" + a);
> ```
>
> 因为上面定义的局部变量`a`会和Lamb表达式中的`a`同名，它们共用一个作用域。

## 优缺点

> `>(red)`
>
> 1. 优点：
>
>    1. **极大得简化了代码，使代码变得更加优雅。**
>
>    2. 函数式编程的代表，可能是未来高端的编程趋势
>
>       - Lambda表达式在Stream API中，配合集合类去使用，代码非常优雅和简洁，并且高效，实际开发中十分常用。
>
>       ###### Stream API代码
>
>       ``` java
>       list.
>         stream().
>       	filter(stu -> stu.getAge() >= 18).
>       	map(Student::getScore).
>       	forEach(System.out::println);
>       ```
>       
>       注：该Stream API完成，将学生对象集合中的，所有大于等于18岁的学生的成绩输出的工作。
>
> 2. 缺点：
>
>    1. 过于简单的Lambda表达式，显然可读性很低。
>    2. 过于简洁也意味着不容易Debug。（当然idea有专门调试Lambda表达式的功能）
>    3. 语法难度不低，熟练使用需要时间锻炼。

###### The End
