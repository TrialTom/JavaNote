###### <sub><font color = orange>JAVASE基础教程</font></sub><br />——<br /><sup><font color=white>卷4</font></sup><font color=white>数组</font><br/><sup><sub><font color=cyan>节3</font></sub><font color=cyan>JVM内存模型</font></sup><br/><br/>	``#最新版本|V3.0#(purple) ``<br/>**长风**<br/>*COPYRIGHT ⓒ 2021. 王道版权所有*

[TOC]

# JVM运行时数据区域

> `>(green)`
>
> 程序在运行期间，需要处理很多数据，JVM中有专门的区域来存放这些数据，这片区域称之为**JVM的运行时数据区域**。
>
> 在这片区域中，变量显然不可能是杂乱无章的随意存放的， <font color=red>**而是被JVM分区管理的：**</font> 这些区域各有各的用途，创建时间，销毁时间等特点皆有不同，与之相对应的，不同区域中存放的变量的生命周期、特点和使用方式也会随之产生差异。
>
> **理解JVM运行时内存是学习Java的基本，这个东西并不底层，需要每位同学都掌握。**
>
> **理解JVM运行时内存，能够加深我们对Java中的很多现象的理解。**

# JVM运行时内存模型图

> `>(green)`
>
> 为了描述JVM运行时内存空间，Java的开发者在《Java虚拟机规范》中指出：JVM （运行时数据区）内存共分为：
>
> 1. JVM栈
> 2. 堆
> 3. 方法区
> 4. 程序计数器
> 5. 本地方法栈
>
> 这五大区域，示意图如下：
>
> <img src="https://hixiaodong123.oss-cn-hangzhou.aliyuncs.com/typora/202112291934354.png?align=center" alt="JVM运行时内存模型" style="zoom: 50%;" />
>
> **为了方便简化交流，以后我们统一称呼JVM运行时内存模型为JVM内存模型。** 下面详细解释一下各个区域的用途：
>
> 1. JVM栈（以后简称栈，stack）：描述的是Java的（普通）方法执行时的所占内存的内存模型。程序运行时调用方法的代价是：方法中有局部变量需要开辟空间存储，方法的执行过程会产生中间变量，方法执行完毕还需要存储返回地址等等。JVM栈正是Java的（普通）方法执行时所占用的内存空间， <span style=color:red;background:yellow>**局部变量会直接存储在栈帧中。**</span>
>
>    于是，方法的执行流程，在JVM内存中，就变成下面这样：
>
>    1. 每当Java程序执行一个方法，都会在栈上分配一块只属于该方法的内存区域，称之为`栈帧`
>    2. 每当Java程序执行一个方法，都会将一个存储该方法信息的**栈帧**压入栈中，称之为`方法进栈`
>    3. 方法进栈的同时局部变量开辟内存空间存储值，局部变量生效。
>    4. 当方法执行完毕后，该方法的栈帧随之销毁，称之为`方法的出栈`
>    5. 方法栈帧被销毁的同时，局部变量也被销毁，局部变量失效。
>
>     <span style=color:red;background:yellow>**注：栈中只有处于栈顶的栈帧才会生效，表示正在执行的方法。称之为当前栈帧，当前方法。**</span>
>
> 2. 堆（heap）：堆是JVM内存中最大的一块，new出来的东西（称之为`对象`或者`实例`）都在堆上。 <span style=color:red;background:yellow>**所以new关键字的语义就是：在堆上开辟一片空间给相应的对象。**</span>而这片空间（对象）是有内存地址的，这个内存地址是留给外界访问用的。
>
>    注：引用数据用比较运算符比较的地址就是这个地址，即比较对象的内存地址。
>
> 3. 方法区（method area）：面向对象详细讲。
>
> 4. 本地方法栈：和JVM栈类似，区别是本地方法栈是给本地（native）方法使用的，而不是普通方法。
>
> 5. 程序计数器：JVM执行代码解释执行的，即是一行一行执行字节码的，程序计数器用来记录当前执行的行数。
>
> ---
>
> 很明显，在JVM内存模型中，相对比较重要的，和程序的执行联系更紧密的是：堆和JVM栈。堆内存用来存储对象，由于Java是面向对象语言，Java面向对象程序中将会有非常多的对象，所以 <font color=red>**堆内存主要决定了Java程序的数据如何存储的问题。**</font>而JVM栈用来表示方法的执行流程， <font color=red>**它决定了程序如何执行，或者说如何处理数据。**</font> 

# 扩展和引申

> `>(green)`
>
> 明白上述JVM内存模型后，很多以前模糊不清的概念我们就可以解释了。

## 什么是引用数据类型

> `>(green)`
>
> 引用数据类型是Java的两大数据类型之一，通过数组初始化的内存分配过程来一窥引用数据类型的特点。
>
> 引用数据类型的创建分为两部分：
>
> 1. 首先是在栈上分配一片空间给引用数据类型的引用，简称`引用`，它是一个局部变量，直接存储在栈帧中。
> 2. 在堆上开辟一片空间，用于存放引用数据类型的实际信息，称之为`对象`或者`实例`
>
> ---
>
> 虽然有两个部分，但**对象才是引用数据类型的实质**，栈上的引用通过存储对象的地址，指向了堆上对象，这样就可以通过引用间接访问堆上的对象。
>
> **总结来说就是：对象是实质，但我们不能直接访问堆上的对象，而是通过栈上的引用间接访问。**

## 基本数据类型和引用数据类型的区别

> `>(green)`
>
> 基本数据类型的变量必然都是局部变量，你可能会疑惑，数组的元素也可以是基本数据类型，那它们不是局部变量啊。实际上我们不应该这么去思考，数组中的元素其实已经是（数组）对象的一部分了，它不应该单独拎出来看。所以它们的区别在于：
>
> 1. 存储位置（本质区别）
>
>    1. 基本数据类型不存在`引用`的概念，数据都是直接存储在栈上的栈帧里；
>
>    2. 引用数据类型在栈帧中存储引用，引用作为一个局部变量，存储的只是该引用类型在堆上对象的内存地址。
>
>       存储在堆上的对象存储具体信息，才是引用数据类型的实质
>
> 2. 引申出，打印变量名区别：
>
>    1. 基本数据类型，打印变量名就是该变量具体的数值
>    2. 引用数据类型，没有办法直接访问对象，打印变量名（引用）会显示该引用存储的堆上的对象的内存地址。

## 堆和栈中内容的区别

> `>(red)`
>
> 我们从以下三个角度来分析这个问题：
>
> 1，从存储的类型来看
>
> 2，从默认值来看
>
> 3，生命周期来看
>
> ---
>
> 1. 从存储的类型来看：
>
>    1. 堆上存储的是new出来的东西，是引用数据类型的实质——对象。
>    2. 栈上存储的是局部变量（基本数据类型和引用类型的引用）
>
> 2. 从默认值来看：
>
>    1. 堆上的变量具有默认值
>       - 整形（byte、short、int、long）默认值为0
>       - 浮点类型（float、double）默认值为0.0
>       - 字符类型（char）默认值是'\u0000' 表示编码值为0的字符，一个绝对空字符。
>       - 布尔类型（boolean）默认值是false
>       - 引用数据类型默认值是null 
>         - null既不是对象也不是任何一种数据类型，它仅是一个特殊的值
>         - 任何引用数据类型的引用都可以指向null，指向null并不意味着没有初始化，可以认为引用指向了虚无，反正没有指向任何一个对象。
>         -  <span style=color:red;background:yellow>**对象才是引用数据类型的实质，没有指向对象的引用实际上没有任何意义，指向null的引用是无法正常使用的**</span>
>         - 基本数据类型不能等于null
>    2. 栈上的局部变量没有默认值，声明局部变量后必须显式的初始化，否则无法使用。
>
> 3. 生命周期来看：
>
>    1. 堆上的对象使用完毕后，随着方法的出栈，对象的引用就会被销毁。这个时候对象就没有引用指向它，而是"孤零零"的单独存在于堆上，这种对象意味着我们就无法再次使用它了，这种对象没有意义了。在Java中，我们把这种对象称之为`垃圾`或者`垃圾对象`，它们会等待垃圾回收器进行内存回收。
>
>       关于Java的垃圾回收机制（Garbage Collection简称GC）：
>
>       - 堆上的对象变成`垃圾`后，并不是立刻就会被回收，而是需要GC通过一系列的算法来决定它是否被回收。
>       - Java的GC机制是全自动的，程序员几乎无法干涉和主动回收`垃圾`。这一方面为Java程序员的开发节省了大量的精力（无需花费大量精力来管理堆内存），相比于C++的全手动回收`垃圾对象`，Java在GC机制上的创新是Java能够如此流行的重要原因之一。但另一方面，一旦GC这种机制出现问题，对Java而言将会是非常难以解决的问题。
>       - 垃圾回收是Java和C++之间的一道围墙，墙外的人想进来，墙内的人却想出去。
>
>    2. 栈上的局部变量的生命周期和栈帧保持一致。方法栈帧进栈后，局部变量开辟空间生效了，方法出栈后，局部变量就被销毁了。

## 对象中元素的默认初始化

> `>(red)`
>
> 在Java的面向对象设计中，一个非常重要的原则就是——通过`new`关键字在堆上开辟空间，创建对象时，对象中的元素需要进行赋值。在现在的数组和后面的面向对象知识中，我们会学习非常多给对象中元素赋值的方式，但是 <span style=color:red;background:yellow>**不管赋值的方式有多少种，对象种元素赋值的第一步永远是——默认初始化，具有默认值。**</span>这是一个非常重要的知识点，希望大家牢记。
>
> 举个例子来说，我们都知道数组的静态初始化，是直接给出数组对象的元素值。那么元素的值就是直接赋我们给出的具体值吗？结合上面，显然不是，**必须先默认初始化，具有默认值，然后才能赋其它具体值。**

> `>(green)`
>
> `一个经典的初学者问题`
>
> > 既然引用数据类型具有默认初始化，对象中的元素具有默认值，那为什么声明一个数组后为什么不能立刻使用呢？

# 内存图解的练习

> `>(red)`
>
> 练习1：
>
> > 静态初始化一个数组，输出数组名及元素。然后给数组中的元素赋值，再次输出数组名及元素。
>
> 练习2：
>
> > 分别静态、动态初始化两个数组，分别输出数组名及元素。然后分别给数组中的元素赋值，再次分别输出数组名及元素。
>
> 练习3：
>
> > 定义两个数组：
> >
> > - 静态初始化一个数组，输出数组名，元素取值，长度
> > - 然后声明第二个数组，把第一个数组的地址赋值给第二个数组。
> > - 输出第二个数组的数组名，元素取值，长度
> > - 然后给第二个数组赋值，再次输出两个数组的名及元素
>

###### The End
