###### <sub><font color = orange>JAVASE基础教程</font></sub><br />——<br /><sup><font color=white>卷3</font></sup><font color=white>方法</font><br/><sup><sub><font color=cyan>节2</font></sub><font color=cyan>方法的重载</font></sup><br/><br/>	``#最新版本|V3.1#(purple) ``<br/>**长风**<br/>*COPYRIGHT ⓒ 2021. 王道版权所有*

[TOC]

# 引入

> `>(red)`
>
> 引例，现在有三个需求，需要写三个方法完成：
>
> 1. 编写程序，计算两个int类型数据之和，并输出结果
> 2. 编写程序，计算两个double类型数据之和，并输出结果
> 3. 编写程序，计算两个long类型数据之和，并输出结果
>
> 写完方法后，请问这个程序有哪些缺点呢？
>
> ---
>
> 很明显：
>
> 这三个方法实现的都是相似的功能，都是求和，只不过是针对的数据类型不同罢了。在正常情况下，我们认为方法的名字可以用来区分方法，但像引例中功能几乎一样的多个方法，能不能让它们拥有相同的方法名呢？这样既方便记忆，也方便调用。
>
> Java是存在这种机制的，那就是Java的方法重载（overload）机制。方法重载允许一个类中，多个方法拥有相同的名字。但名字一旦相同后，多个方法之间又如何区分呢？**所以方法的重载是有条件的。**

#  语法要求

> `>(green)`
>
> 语法要求：
>
> >  <span style=color:red;background:yellow>**一个类中的多个方法，可以具有相同的方法名，但是它们的形参列表必须不同。**</span>
>
> 形参列表不同意味着：
>
> 1. 形参数量不同
> 2. 形参数量相同时，形参的数据类型不同
> 3. 形参数量和数据类型都相同时，形参的数据类型的顺序不同
>
> 除开上述条件外，其余的任何不同都无法构成方法重载， <font color=red>**经典的错误**</font>有：
>
> 1. 形参的名字不同，可以构成方法重载<font color=red>✖</font>
> 2. 返回值类型不同，可以构成方法重载<font color=red>✖</font>
> 3. 修饰符列表不同，可以构成方法重载<font color=red>✖</font>
>
> ---
>
> **请明确记住，方法的重载只与方法的签名有关。即在方法名相同的情况下，方法签名不同，参数列表不同**

请思考：

如果我想在很多方法中，唯一地找到一个方法，需要明确什么？

# 实参的自动类型转换在重载中的应用

> `>(green)`
>
> 先回答上面思考的问题：
>
> > 方法的调用必须能够让编译器明确找个某个方法，当多个方法的方法名相同，形参列表还相同的话，就无从唯一确定一个方法了。所以**要想唯一确定一个方法，必须明确方法的名字和形参列表，而它两合起来就称之为"方法的签名"，这就是签名的由来。**
>
> 一个类中发生方法重载时，方法名既然相同了，为了确保签名不同，那形参列表就必须不同了。
>
> 现在看以下代码：
>
> ###### 重载案例1
>
> ``` java
> // 方法1
> public static void test(int a){}
> // 方法2
> public static void test(double a){}
> // 方法3
> public static void test(float a){}
> ```
>
> 如果调用的语句是：
>
> ``` java
> test(10);
> ```
>
> 请问调用的是方法几呢？
>
> > 在方法的概述这一节中，我们讲过：实参能够自动类型转换去匹配形参的数据类型，看起来方法1、2、3都能够匹配，那么究竟该选谁呢？这就不得不提，Java设计原则中一个非常重要的原则： <span style=color:red;background:yellow>**就近原则**</span>

> `>(red)`
>
>  <span style=color:red;background:yellow>**就近原则**</span> 指的是：当有多个选项都能正确匹配时，那么优先选择"最近"的。
>
> 回到上面那个案例，显然方法1最近，因为它不需要类型转换。而如果去掉方法1，那么方法3将胜出，因为它类型转换的"距离"会"近"一点。
>
> 理解就近原则，需要活学活用，以后我们还会碰到，到时候再解释。

> `>(green)`
>
> 除了就近原则，这里我们还要讲一个很重要的注意事项，先看代码：
>
> ###### 重载案例2
>
> ``` java
> // 方法1
> public static void test(int a,double b){}
> // 方法2
> public static void test(double a,int b){}
> ```
>
> 假如调用的代码是：
>
> ``` java
> test(10, 10);
> ```
>
> 请问调用的是方法1还是方法2呢？
>
> 显然不好确定，无论是1还是2都需要类型转换才能匹配，既然都转换，并且都是int--->double，那么到底谁"近"呢？
>
> 实际上这个方法的调用，是一个模糊的调用，会编译报错。这一点在开发中，多个方法组成方法重载时，要格外注意。

# 小练习

> `>(red)`
>
> 小试牛刀：
>
> 1. 使用方法重载，输出各种数据类型
> 2. 实现一个功能更强大的计算器

# 使用场景

> `>(green)`
>
> - 实现相似的功能（功能差不多，只是传入的参数不同时）
>

###### The End
