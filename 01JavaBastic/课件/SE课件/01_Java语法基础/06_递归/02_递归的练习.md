###### <sub><font color = orange>JAVASE基础教程</font></sub><br />——<br /><sup><font color=white>卷6</font></sup><font color=white>递归</font><br/><sup><sub><font color=cyan>节2</font></sub><font color=cyan>递归的练习</font></sup><br/><br/>	``#最新版本|V2.0#(purple) ``<br/>**长风**<br/>*COPYRIGHT ⓒ 2021. 王道版权所有*

[TOC]

# 前言

> `>(green)`
>
> 递归本身的定义，其实是非常简单的，简单的使用递归也没有任何难度。但可惜的是，生活中的问题几乎都很复杂。本小节中，给出一个经典的案例——汉诺塔问题，作为补充练习。**一个问题，想要用递归的方式求解，某种程度上，有点像做一道数学题，首要的是要往递归的思想——分解问题，上去靠。** 
>
> 前面我们已经说过了，递归很危险，谨慎使用。但还是不得不承认，有一些问题，如果不用递归，不仅很难想到思路，代码也会很复杂，所以递归这把🔪还是"锋利"的。

# 小案例

> `>(green)`
>
> 小案例：
>
> > 周末晚上你和对象一起去看电影，月黑风高，伸手不见五指
> >
> > 对象悄悄地问你：我们现在在第几排？
>
> 我们排除作弊的方法，只能靠数，那怎么办呢？
>
> 利用递归思想：
>
> > 我的座位的排数 = 1 + 前面一排的人的排数
> >
> > 前面一排的人的排数 = 1 + 再前面一排的
> >
> > ....
> >
> > 坐在最前面的人，前面没座椅了，他会知道他的排数 = 1
>
> 当然，这只是举个例子，去电影院不要尝试这么做。

# 汉诺塔问题

> `>(red)`
>
> 汉诺塔（Hanoi）问题，是经典的递归问题，学习递归一般都绕不开它，这里我们就学习一下如何使用递归求解汉诺塔问题。
>
> 首先看一下汉诺塔问题的描述：
>
> > 相传在古印度的圣庙中，有一种被称之为汉诺塔（也叫河内塔，Hanoi）的游戏
> > 简单来说：有三个塔1，2，3，塔1上有 N 个（N>1）穿孔圆盘，大盘在下，小盘在上
> > 要求按下列规则将所有圆盘移至塔3：
> > 	1，每次只能移动一个圆盘
> > 	2，大盘一定在小盘之下
> > 提示：可将圆盘临时置于塔2，也可以将塔1的圆盘重新移回塔1，但都必须遵循上述两条规则
> > 问：当塔1上有N（N>=1）个圆盘时，最少要移动多少次？（注意是最少）
>
> 怎么做呢？还是那句话，要往`分解`的方向去靠，分析如下：
>
> 1. 当N = 1时，直接把盘子从塔1到塔3，仅需1步
> 2. 当N=2时，先把小盘子移到塔2，再把大盘子移到塔3，最后把小盘子放入塔3，共3步
> 3. 当N=3时，先把最小的盘子移到塔3，再把中间的盘子移到塔2
>    1. 然后把最小的盘子移到塔2，最大的盘子移到塔3
>    2. 随后最小的盘子移到塔1，中间的盘子移到塔3，最小的盘子移到塔3，共7步
> 4. ....
>
> ----
>
> 其实玩三次就可以总结规律了，**现在我们假设N个盘子，至少需要f(N)次完成汉诺塔问题，**于是：
>
> 要想塔1的盘子全部移到塔3，可以分解为三步：
>
> 1. 首先要把塔1中最大的盘子移到塔3，所以需要把`N-1`个盘子从塔1移到塔2，这个过程需要借助塔3的辅助。 <font color=red>**这一步就是把N-1个盘子从一个塔移到另一个塔，共需要f(N-1)步。**</font>
> 2. 现在塔1上只有最大的盘子，且塔3是空的，于是将塔1上的最大的那个盘子，移到塔3上。 <font color=red>**共需要1步完成。**</font>
> 3. 现在塔2上有N-1个盘子，塔1是空的。最后一步就只需要再将`N-1`个盘子从塔2移到塔3，这个过程需要借助塔1辅助。 <font color=red>**这一步就是把N-1个盘子从一个塔移到另一个塔，共需要f(N-1)步。**</font>
>
> 于是，我们就已经完成了对汉诺塔问题的分解：
>
> > 对于N个盘子，假设至少需要f(N)步完成汉诺塔问题
> > 那么可以做以下分解：
> > 	步骤1：需要f(N-1)步
> > 	步骤2：1步
> > 	步骤3：f(N-1)步
> > f(N-1)仍然可以继续分解
> > ....
> > 最终，f(1) = 1
>
> 以上，完美符合递归的思想，找出递归体和递归出口后，即可写出递归代码，参考如下：
>
> ###### 递归求解汉诺塔问题
>
> ``` java
> //求解汉诺塔问题
> public static long hanoi(int n) {
>   	//写递归的出口
> 		if (n == 1) {
>       return 1;
>     }
> 		return hanoi(n - 1) + 1 + hanoi(n - 1);
> }
> ```
>
> 完毕~

> `>(green)`
>
> 神话传说中的汉诺塔，这是一个印度神话：
>
> > 传闻大梵天创造世界的时候做了三根金刚石石柱，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。**僧侣们预言，当所有的金片都从梵天穿好的那根针上移到另外一根针上时，世界就将在一声霹雳中消灭，而梵塔、庙宇和众生也都将同归于尽。**
>
> 我们不妨算一算，实际上僧侣要想将所有金片都移到另一根柱子上，在完全不出错的情况下，也至少需要2的64次方减1次，即便是一秒移动一次，也需要超过5849亿年。
>
> 而按照目前人类理解的主流的`宇宙大爆炸`计算的宇宙年龄，也不过150亿年，而地球的年龄才区区46亿年，甚至都不够零头。过了这么久，世界终于毁灭了，也难为世界了。

###### The End
