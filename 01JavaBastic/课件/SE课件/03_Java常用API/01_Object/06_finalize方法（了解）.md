###### <sub><font color = orange>JAVASE基础教程</font></sub><br />——<br /><sup><font color=white>卷1</font></sup><font color=white>Object类</font><br/><sup><sub><font color=cyan>节6</font></sub><font color=cyan>finalize方法（了解）</font></sup><br/><br/>	``#最新版本|V1.0#(purple) ``<br/>**长风**<br/>*COPYRIGHT ⓒ 2021. 王道版权所有*

[TOC]

# 方法的声明

> `>(green)`
>
> finalize方法的声明和方法体比较简单，如下：
>
> ``` java
> protected void finalize() throws Throwable { }
> ```
>
> 首先注意访问权限是protected，这说明在不重写访问权限的情况下，仅能够在自身类中创建自身对象，才能调用这个方法。
>
> 其次它的方法体是空的，功能没有实现，这种设计的目的是为了让子类自己去重写该方法的实现。这种做法比起抽象方法的强制子类实现，要更加灵活，而且可以用在普通类中。
>
> 最后，它的方法声明中有一个`throws Throwable`， 这是方法抛出异常列表的声明，现在不用管它，后面会讲。

# 方法的作用

> `>(green)`
>
>  finalize方法是Java沿用的C++中的`析构函数`的设计。
>
> 在C++当中，负责对象的生命周期的，有两个函数：
>
> 1. 构造函数，用来在对象**"出生"**时，给成员变量赋值，在Java当中对应构造器。
> 2. 析构函数，用来在对象销毁时，给对象的死亡做"善后"工作，在Java中就对应` finalize方法`。
>
> 所以要搞明白finalize方法的作用，就要搞清楚析构函数的作用，理解何为对象死亡的"善后"工作。

# 对象资源占用的情况

> `>(green)`
>
> 无论是Java还是C++中，一个对象在内存中都普遍占用两种资源：
>
> 1. 对象在内存中存在，本身就是要占用内存的，这个内存在对象销毁时就会随之释放。这个释放的过程在不同的语言当中，形式是不同的，比如C++是程序员手动释放的，Java依赖是GC自动完成释放。但不管是什么形式，这些对象所占用的内存都是可以准确释放的。
>
> 2.  对象在存在时，很多时候不仅自身要占用内存，还可以需要去使用一些系统资源，占用一些系统资源，比如：
>
>    1. 做I/O操作时，需要占用系统的I/O资源。
>    2. 做网络操作，要占用网络资源。
>    3. ...
>
>    那么这些系统资源，在对象使用后，也要被释放掉，不然就会一直被占用，可能就会产生不良问题。
>
>    C++当中的析构函数就是完成这个功能的。程序员将释放资源的语句写进析构函数中，在对象销毁时，该函数自动被调用，自动去释放对象占用的系统资源。
>
> ----
>
> **Java当中的finalize方法就是"模仿"析构函数设计的，finalize方法也会在对象销毁时自动被调用，我们Java程序员只需要把释放资源的代码放在finalize方法中，就可以完成对象销毁的"善后"工作。**
>
> 理想是很美好的，因为有这个finalize方法后，Java的资源释放代码，就可以统一地写进一个方法中，还会自动调用，多么方便的一种设计啊。
>
> 可惜现实是很骨感的，实际上根本达不成这种目的。

> `>(red)`
>
> 这里就体现了`Java GC`自动垃圾回收的缺点：程序员缺乏对对象销毁的控制，对象的垃圾回收具有不确定性，没有时效性。**那么连带着finalize方法的执行也是不确定的。**在这段不确定长度的时间里，对象其实早就已经没用了，但系统资源还是一直被占用着，造成资源的浪费。 <span style=color:red;background:yellow>**显然释放系统资源这么一件重要的事情，不能依赖于一个不稳定的机制。**</span>
>
> 从Java9开始，Java官方正式将该方法标记为`@Deprecated`，表示这个方法已经被放弃使用了。

# 测试finalize方法

> `>(green)`
>
> 如果你仍然感兴趣finalize方法，为什么不靠谱。这里给出一个测试代码，感兴趣自己玩一下：
>
> ``` java
> public class Demo {
>     public static void main(String[] args) {
>       	// 匿名对象,理论上很快成为垃圾对象
>         new Student();
>         // 通知GC进行垃圾回收
>         System.gc();
>     }
> }
> class Student{
>     @Override
>     protected void finalize() throws Throwable {
>         System.out.println("模拟释放资源");
>     }
> }
> ```
>
> 上述代码执行，你就会发现`模拟释放资源`一会打印了，说明方法执行了；一会又不打印，说明方法没有调用。这种不靠谱的机制，是不可能真的用来做资源释放的。
>
> <span style=color:red;background:yellow>**在Java中，所有的资源释放，都必须依赖程序员手动完成，所以以后大家做I/O操作，网络操作，数据库操作等需要占用系统资源的操作时，一定不要忘记在用完后，释放系统资源！**</span>

# 总结

> `>(green)`
>
> finalize()方法是典型的Java拿来C++机制想要使用，但是失败的案例，这是自动垃圾回收便利的代价，你不得不放弃对系统资源释放的控制。
>
> 总之就是一句话：这玩意没用，但是知道它可以增长见识（装个杯罢鸟

###### The End
