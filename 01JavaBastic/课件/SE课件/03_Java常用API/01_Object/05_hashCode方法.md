###### <sub><font color = orange>JAVASE基础教程</font></sub><br />——<br /><sup><font color=white>卷1</font></sup><font color=white>Object类</font><br/><sup><sub><font color=cyan>节5</font></sub><font color=cyan>hashCode方法</font></sup><br/><br/>	``#最新版本|V1.0#(purple) ``<br/>**长风**<br/>*COPYRIGHT ⓒ 2021. 王道版权所有*

[TOC]

# 方法的声明

> `>(green)`
>
> hashCode()方法的方法声明：
>
> ``` java
> public native int hashCode();
> ```
>
> 很显然，它是一个本地方法，这个方法也没有任何参数，返回值是一个int类型整数。

# 方法的作用

> `>(green)`
>
> 由于它是一个本地方法，我们通过查阅JDK文档，文档中关于它的作用说明了两点：
>
> 1. 返回该对象的哈希码值。
> 2. 支持此方法是为了提高哈希表（例如 java.util.Hashtable 提供的哈希表）的性能。
>
> 关于哈希表、哈希码值等相关的概念，如果你对`数据结构`这门课程有些了解，那么这些概念就是非常容易的。当然如果你还不太明白，就看一下下面的说明。

## 哈希的概念

> `>(green)`
>
> 映射的概念：
>
> > 设A和B是两个非空集合，并存在某种对应关系f
> >
> > 按照这种对应关系f，对于集合A中的任何一个元素a，在集合B中都存在唯一的一个元素素b与之对应
> >
> > 那么，这样的对应（包括集合A，B，以及集合A到集合B的对应关系f）叫做集合A到集合B的映射
>
> 如果用图描述的话，就是下图：
>
> <img src="https://hixiaodong123.oss-cn-hangzhou.aliyuncs.com/typora/202201121211877.png?align=center" alt="映射图解" style="zoom:33%;" />
>
> 注意：
>
> 1. 我们数学中学习的函数，其实是一种特殊的映射。（函数只不过是集合A、B是数集的映射罢了）
> 2. <span style=color:red;background:yellow>**映射不要求元素一一对应，允许出现多对一，但绝不允许一对多。**</span>
>
> ---
>
> 明白映射的概念后，哈希映射就不难理解了。哈希映射也是一种特殊的映射，要求：
>
> 1. 集合A必须是一个无限大小，具有无穷多元素的集合。
> 2. 集合B必须是一个元素有限的集合。
>
> `化无限为有限`，这就是哈希映射。
>
> 在哈希映射当中，集合A和B之间的对应关系f，就是一种映射的规则，称之为`哈希函数`、`哈希方法`或者`哈希算法`等。
>
> 而通过哈希算法，求得的集合B中的元素，求称之为`哈希值`。
>
> `化无限为有限`，这本身就是不现实的，更不可能强求映射是完全一一对应的。所以在哈希映射中，出现`多对一`是相当正常的，称之为**"哈希冲突"**。
>
> ---
>
> 在Java当中，hashCode方法可以看成是哈希映射的一个算法，也就是映射中的对应关系f，该方法的作用是：
>
> 1.  <span style=color:red;background:yellow>**将一个无限大小的集合（某个类的对象的集合）映射到一个有限大小的集合（int整数）上。**</span>
> 2.  <span style=color:red;background:yellow>**方法返回的一个int整数，这个整数就是该对象的哈希值。**</span>
>
> 现在你已经大概知道，什么是哈希映射，什么是哈希值了。那么再回到JDK当中的方法说明上：
>
> 1. 返回该对象的哈希码值。
> 2. 支持此方法是为了提高哈希表（例如 java.util.Hashtable 提供的哈希表）的性能。
>
> 第一条很简单，已经理解了。
>
> 重点就是第二行，那什么是哈希表呢？

## 哈希表

> `>(green)`
>
> 哈希表的详细概念，后面在`数据结构`章节中，老师会详细讲解，这里我们可以先简单了解一下。
>
> 哈希表（也叫散列表）可以简单看成是一种存储`键值对Key-Value`的数据结构，在实际开发中非常常见。比如用户登陆的"用户名——密码"就是典型的键值对。哈希表的实现，本质还是一个数组，**哈希表具有数组访问快的特点，还能存储键值对数据。**
>
> Java当中的哈希表实现，Key和Value都必须是一个对象，通过调用类中的`hashCode方法`计算Key（哈希表中Key是唯一的）对象的哈希值，决定这个键值对在数组中的存储位置（也就是存储元素的数组下标）。而如果出现`哈希冲突`：表示它们在数组中的存储位置一样，这时总不可能让数组一个位置存两个元素。常见的做法就是采用`链表`将它们挂在数组下面，然后每个`节点`都存储下一个节点的地址（引用）。Java中的哈希表的实现，大致就如下图所示：
>
> <img src="https://hixiaodong123.oss-cn-hangzhou.aliyuncs.com/typora/202201112124550.png?align=center" alt="Java哈希表的实现" style="zoom: 33%;" />
>
> 将`Key-Value数据`按照上述结构存储后，我们就可以通过Key获取哈希值，首先找到数组的下标，然后如果存在`哈希冲突`，数据被"挂"在链表中了，就还需要遍历链表，逐一比对Key，找到我想要访问的`键值对数据`。
>
> <font color=red>**显然，在哈希表中，哈希冲突越少越好，冲突少了，存得也快，取得更快，哈希表的性能就能提升。**</font>所以Java当中hashCode方法（哈希算法）的实现，是很重要的。接下来，我们来首先看一下Object类当中，它的默认实现。

# Object默认实现

> `>(green)`
>
> Object默认的hashCode方法，是一个本地方法，我们没办法直接看代码分析方法的实现。在JDK文档中，是这么描述的（原话）：
>
> >  实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个int整数来实现的，但是 Java 编程语言不需要这种实现技巧。）
>
> 这说明什么呢？默认情况下，哈希值是通过计算对象的地址值来获取的。**这样的话，一般两个独立的对象的哈希值是不同的，而同一个对象（用两个引用调用方法）它们的哈希值必然是相同的。**

# 方法的重写

> `>(green)`
>
> 在很多时候，我们都需要重写hashCode方法，JDK文档中给我们标注了重写的规则和什么时候进行重写，如下：
>
> 1. 在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals比较时所用的信息没有被修改。
> 2. 如果根据 `equals(Object)方法`，两个对象是相等的，那么对这两个对象中的每个对象调用hashCode方法都必须生成相同的整数结果。
> 3. 如果根据 `equals(java.lang.Object) `方法，两个对象不相等，那么对这两个对象中的任一对象上调用hashCode方法不要求一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。
>
> 上述三条，告诉了我们：
>
> 1. hashCode方法和equals方法是息息相关的，要重写必须一起重写。
>    1. 一起重写后，必须符合`equals方法返回true，那么这两个对象的哈希值必须相同`的规则。
>    2. 这是**因为equals是判断对象相等的，对象相等后，就相当于是上述映射定义中，集合A中的同一个元素，那么它们哈希映射的结果必然相同。**这是映射定义强制要求的。
>    3. 哈希冲突是允许存在（不允许也不可能）的，但是我们要清楚，设计出更好的哈希算法，尽量避免哈希冲突，可以提升哈希表性能。（ <span style=color:red;background:yellow>**虽然完美永远是达不到的，但我们要相信光。**</span>）
>
> 最后，还是要强调一下，hashCode方法和equals方法要重写必须一起重写，而且重写的依据必须是一样的，这样才能保证两个方法的结果具有一致性。<span style=color:red;background:yellow>**比如一个Student类，如果equals方法依据其中的成员变量age和name重写的，那么hashCode方法也必须要依赖于这两个成员变量重写！！**</span>

## 具体怎么重写呢？

> `>(green)`
>
> 知道重写的原则后，就是具体`算法`的设计了，这个就主要靠自己开动脑筋了。好在IDEA知道程序员们都不愿动脑筋，IDEA也给hashCode方法的重写提供快速生成，即使用快捷键`Alt + Insert`。
>
> 按下快捷键选择重写hashCode方法后，会要求你选择重写依据的成员变量，这时要注意，<span style=color:red;background:yellow>**一定要保持和equals方法一致的重写依据。**</span>
>
> 具体代码这里不再贴出，实际开发中，如无特殊需求，使用IDEA自动生成的哈希算法，足够了。有特殊需求，再说。

## 为什么要同时重写hashCode方法和equals方法

> `>(red)`
>
> 首先hashCode方法中规定：
>
> 1. **两个对象相等，哈希值一定相等。**
> 2. **两个对象不相等，哈希值不要求完全不相等。**
>
> 那么这里就很明显存在一个问题：
>
> 如何判断对象相等？答：依赖类中的equals方法！
>
> 对于下列代码：
>
> ###### 举例
>
> ``` java
> // Studnet类存在String name和int age的双参构造器
> Student s1 = new Student("小明",18);
> Student s2 = new Student("小明",18);
> ```
>
> 1. 假如只重写了Student类的equals方法，没有重写hashCode方法，那么：
>
>    **s1对象明明和s2对象相等，但哈希值却不相等。（因为默认的hashCode方法按照对象地址计算）**
>
>    这严重违背原则！
>
> 2. 假如只重写了Student类的hashCode方法，没有重写equals方法，那么：
>
>    **s1对象明明和s2对象不相等，但哈希值却一定相等。**
>
>    这也不符合原则！

# 注意事项

> `>(red)`
>
> 1. **一旦重写hashCode方法后，默认的toString方法就不会再打印地址值了。这是因为toString方法，默认调用的是本地方法的hashCode方法获取地址值，重写后不再是地址值了。**
> 2. 如果类中有引用数据类型成员变量，那么就继续调用它的hashCode方法，也就需要重写它的hashCode方法。

###### The End
