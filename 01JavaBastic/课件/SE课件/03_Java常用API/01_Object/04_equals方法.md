###### <sub><font color = orange>JAVASE基础教程</font></sub><br />——<br /><sup><font color=white>卷1</font></sup><font color=white>Object类</font><br/><sup><sub><font color=cyan>节4</font></sub><font color=cyan>equals方法</font></sup><br/><br/>	``#最新版本|V1.1#(purple) ``<br/>**长风**<br/>*COPYRIGHT ⓒ 2021. 王道版权所有*

[TOC]

# 方法的声明

> `>(green)`
>
> equals方法的声明，比较简单：
>
> ``` java
> public boolean equals(Object obj)
> ```
>
> 仅需要注意两点：
>
> 1. 该方法是有参数的，需要传入一个对象（任意一个对象就行）
> 2. 方法是有返回值的，返回一个布尔类型的值，真或假。

# 方法的作用

> `>(green)`
>
> equals有相同，相等的意思。**所以该方法的作用是，用于指示其他某个对象是否与此对象"相等"。**此对象即调用该equals方法的对象，其它对象即方法实参传入的对象。
>
> 既然是比较对象相等，那自然就需要比较的规则才有意义，比较的规则其实就是方法体中的代码，我们先来看一下Object类当中，默认的比较规则，即equals方法的默认实现。

## equals默认实现

> `>(green)`
>
> Object类当中的equals方法默认实现，认为的对象相等的比较规则：
>
> ###### equals默认实现
>
> ``` java
> public boolean equals(Object obj) {
>     return (this == obj);
> }
> ```
>
> 很显然，这个比较规则非常简单。双等号直接连接引用，比较对象的地址，换句话说是比较两个引用是否指向同一个对象。这个相等的规则就非常苛刻了：
>
> - 只有当两个引用完全指向同一个对象时，方法才会返回true，否则都会返回false。
>
> 换句话说，<span style=color:red;background:yellow>**Object类当中的equals方法默认实现，仅自己和自己比较时，才会返回true。**</span>在多数情况下，我们不需要这样一个苛刻的规则，所以需要自己重写equals方法的实现。

## 重写equals方法的常规协定

> `>(green)`
>
> 既然需要重写equals方法，就需要一个重写的规则，我们认为的对象相等的规则：
>
> 1. 如果不是相同类型的对象，没有可比性，直接认定为不相等。
> 2. 如果是相同类型的对象，行为是一致的，只有成员变量的取值有差异。所以只要，这两个对象的成员变量的取值（对象的状态）是一致时，就认定这两个对象相等。
>
> 对于以上比较规则的equals方法的重写，Java官方为我们提供了官方的要求，称之为`equals方法重写的常规协定`：
>
> 1. 自反性：对于任何非空引用值 x，`x.equals(x) `都应返回 true
> 2. 排他性：当比对的不是同种类型的对象或者是一个null时，默认返回false
> 3.  对称性：对于任何非空引用值 x 和 y，当且仅当` y.equals(x)` 返回 true 时，x.equals(y) 才应返回true
> 4. 传递性：对于任何非空引用值 x、y 和 z，如果` x.equals(y) `返回 true，并且 `y.equals(z)` 返回 true，那么`x.equals(z)` 应返回 true。
> 5. 一致性：对于任何非空引用值 x 和 y，多次调用 `x.equals(y) `始终返回 true 或始终返回 false。
>
> 以上5点常规协定， <span style=color:red;background:yellow>**其中自反性和排它性需要写代码做判断，而对称性，一致性，传递性，只需要用成员变量的取值来判断对象相等，就自动满足它们。**</span>
>
> 按照以上规则重写equals方法，就完成了我们的比较规则，两个相同类型的对象成员变量取值完全一致时，它们就是相等的。

# 重写equals方法的注意事项

> `>(red)`
>
> 1. 在实现排他性时，实际上有两种选择：
>
>    1. **使用getClass方法比较**。  <font color=red>**这个比较是比较苛刻的，只有在完全是同一个类型时才会返回true**</font>
>
>    2. **使用instanceof比较**。
>
>       ``` java
>       引用 instanceof 类名
>       ```
>
>        表示判断引用所指向的对象的具体类型，是否是后面类名的对象或者子类对象，如果是就返回true，如果不是就返回false。
>
>       这个比较的条件就比较宽松了，可以允许传入子类对象。（当子类对象的父类成员和父类对象相同时,equals方法仍然返回true）
>
> 2. equals方法也是可以用快捷键自动生成的，使用快捷键`alt + insert`。而且可以选择在实现`排它性`时的方式。
>
> 3. 浮点数比较特殊，它具有规格化和非规格化的区别，还有非数(NaN)，无穷大，无穷小很多特殊的概念，正常情况下，如果仅仅比较数值，用`==`比较相等是够用的。但为了避免因浮点数特殊值，而出现的错误。实际开发中，从严谨角度出发，浮点数的比较仍然建议使用，对应包装类型的`compare`方法去比较浮点数的大小：
>
>    1. Float.compare(float a,float b)
>    2. Double.compare(double a,doublet b)
>
>    这两个方法在,a < b时返回-1(负数)，在a>b时，返回1(正数)，只有在两个浮点数相等时，才会返回0
>
> 4. 如果类中有引用数据类型成员变量，需要去调用它们的equals方法完成比较。这就意味着还需要重写这个类的equals方法。
>
> 5. 财务金额上的运算是不推荐使用浮点数的，会出现精度问题。推荐使用`BigDecimal`这个类完成运算。

###### The End
