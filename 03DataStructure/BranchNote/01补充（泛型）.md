[TOC]



# 一、泛型

## 1. 概述：

- **参数化类型**，设计一个逻辑的时候，可能不太确定某个参数用什么类型，我们可以先用一个标记来代指这个类型，当使用的时候才传入具体类型。

## 2. 优点：

- 提高了程序的安全性
- 将运行期间遇到的问题转移到了编译时期
- 省去类型强转产生的麻烦

## 3. 泛型的使用

1. 泛型类：把泛型定义在类上

2. 格式：`class 类名<泛型类型1，...>` 

3. 注意：

   - **参数化类型必须是引用类型**

   - 可以给一个泛型类定义多个泛型，但不建议超过两个

   - 使用泛型的标记：T（type），E（element），K（key），V（value）

   - **<span style="background:yellow;color:red">泛型的作用域：仅作用于类名上及类体上，无法继承</span>** 

   - 可以有三种使用方式：

     ``` java
     // jdk1.5标准版本
     User<String> user1 = new User<String>("A");
     // jdk1.7简化版
     User<String> user2 = new User<>("A");
     // 默认Object
     User user3 = new User("A");// 没有指定泛型，默认泛型表现为Object
     ```

## 4. 泛型接口和方法

- 泛型接口
  1. 概述：把泛型定义在接口上
  2. 格式：`interface 接口名<泛型类型1...>` 

- 泛型方法
  1. 概述：把泛型定义在方法上
  2. 格式：`public <泛型类型> 返回类型 方法名(泛型类型...)` 
  3. 注意：
     - 调用时不需要指明泛型代表的类型，会根据上下文自动推断

## 5. 泛型的通配

1. 问题：

   - 为什么Java要设计泛型的通配？

     > 是为了模拟类似数组协变的功效，但是又不想引入数组协变的缺点。
     >
     > **协变的缺点**：运行时类型不匹配问题

2. 实例：

   ```java
   // (1.)通配符<?> ：任意类型，如果没有明确，那么就是Object以及任意Java类
   class A <T>{}
   class B extend A{}
   class C extend A{}
   
   Temp<?> a = new Temp<String>();
   
   // (2.) ? extends E ：向下限定，可以代指E类型，及其E的子类型
   Temp<? extend A> test = new Temp<B>;
   
   // (3.) ? super E ：向上限定，E及其父类
   Temp<? super B> = new Temp<F>;
   
   编译只看代码左边，而根据左边的通配无法确定泛型所代表的类型，所以使用时会产生编译报错
   ```

   

## 6. 泛型擦除

1. 概述：Java中的泛型并不是真正的泛型，Java泛型仅仅存在于编译之前，当编译的时候，泛型会被擦除（变成Object类型，以及类型强转）

## 7. 补充

1. Java中的泛型时JDK1.5时候出现的